[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site\n\n1 + 1\n\n[1] 2"
  },
  {
    "objectID": "01-DataWrangling.html",
    "href": "01-DataWrangling.html",
    "title": "Data Wrangling with R",
    "section": "",
    "text": "By the end of this session, students will be able to:\n\nExplain some benefits of learning R\nUnderstand the difference between R and RStudio\nNavigate RStudio\nDefine key R concepts and terminology.\nIdentify sources of documentation about R packages and functions\nApply commonly used tidyverse functions to a real data set\nBecoming familiar with a typical workflow for exploring and wrangling data."
  },
  {
    "objectID": "01-DataWrangling.html#learning-objectives",
    "href": "01-DataWrangling.html#learning-objectives",
    "title": "Data Wrangling with R",
    "section": "",
    "text": "By the end of this session, students will be able to:\n\nExplain some benefits of learning R\nUnderstand the difference between R and RStudio\nNavigate RStudio\nDefine key R concepts and terminology.\nIdentify sources of documentation about R packages and functions\nApply commonly used tidyverse functions to a real data set\nBecoming familiar with a typical workflow for exploring and wrangling data."
  },
  {
    "objectID": "01-DataWrangling.html#why-learn-r",
    "href": "01-DataWrangling.html#why-learn-r",
    "title": "Data Wrangling with R",
    "section": "Why learn R?",
    "text": "Why learn R?\n\nR is free, open-source, and cross-platform. Anyone can inspect the source code to see how R works. Because of this transparency, there is less chance for mistakes, and if you (or someone else) find some, you can report and fix bugs. Because R is open source and is supported by a large community of developers and users, there is a very large selection of third-party add-on packages which are freely available to extend R’s native capabilities.\nR code is great for reproducibility. Reproducibility is when someone else (including your future self) can obtain the same results from the same dataset when using the same analysis. R integrates with other tools to generate manuscripts from your code. If you collect more data, or fix a mistake in your dataset, the figures and the statistical tests in your manuscript are updated automatically.\nR relies on a series of written commands, not on remembering a succession of pointing and clicking. If you want to redo your analysis because you collected more data, you don’t have to remember which button you clicked in which order to obtain your results; you just have to run your script again.\nR is interdisciplinary and extensible With 10,000+ packages that can be installed to extend its capabilities, R provides a framework that allows you to combine statistical approaches from many scientific disciplines to best suit the analytical framework you need to analyze your data. For instance, R has packages for image analysis, GIS, time series, population genetics, and a lot more.\nR works on data of all shapes and sizes. The skills you learn with R scale easily with the size of your dataset. Whether your dataset has hundreds or millions of lines, it won’t make much difference to you. R is designed for data analysis. It comes with special data structures and data types that make handling of missing data and statistical factors convenient. R can connect to spreadsheets, databases, and many other data formats, on your computer or on the web.\nR produces high-quality graphics. The plotting functionalities in R are endless, and allow you to adjust any aspect of your graph to convey most effectively the message from your data.\nR has a large and welcoming community. Thousands of people use R daily. Many of them are willing to help you through mailing lists and websites such as Stack Overflow, or on the RStudio community. Questions which are backed up with short, reproducible code snippets are more likely to attract knowledgeable responses."
  },
  {
    "objectID": "01-DataWrangling.html#starting-out-in-r",
    "href": "01-DataWrangling.html#starting-out-in-r",
    "title": "Data Wrangling with R",
    "section": "Starting out in R",
    "text": "Starting out in R\nR is both a programming language and an interactive environment for data exploration and statistics.\nWorking with R is primarily text-based. The basic mode of use for R is that the user provides commands in the R language and then R computes and displays the result.\n\nDownloading, Installing and Running R\nDownload\nR can be downloaded from CRAN (The Comprehensive R Archive Network) for Windows, Linux, or Mac.\nInstall\nInstallation of R is like most software packages and you will be guided. Should you have any issues or need help you can refer to R Installation and Administration\nRunning\nR can be launched from your software or applications launcher or When working at a command line on UNIX or Windows, the command R can be used for starting the main R program in the form R\nYou will see a console similar to this appear:\n\n\n\n\n\n\n\n\n\nWhile it is possible to work solely through the console or using a command line interface, the ideal environment to work in R is RStudio.\n\n\nRStudio\nRStudio is a user interface for working with R. It is called an Integrated Development Environment (IDE): a piece of software that provides tools to make programming easier. RStudio acts as a sort of wrapper around the R language. You can use R without RStudio, but it’s much more limiting. RStudio makes it easier to import datasets, create and write scripts, and makes using R much more effective. RStudio is also free and open source. To function correctly, RStudio needs R and therefore both need to be installed on your computer.\nRStudio is divided into four “panes”. The placement of these panes and their content can be customized (see menu, Tools -&gt; Global Options -&gt; Pane Layout).\nThe Default Layout is:\n\nTop Left - Source: your scripts and documents\nBottom Left - Console: what R would look and be like without RStudio\nTop Right - Environment/History: look here to see what you have done\nBottom Right - Files and more: see the contents of the project/working directory here, like your Script.R file\n\n\n\n\n\n\n\n\n\n\n\n\nRStudio Projects\nRStudio provides a useful feature called Projects which act like a container for your work. As you use R more, you will find it useful to make sure your files and environment for one real-world project are kept together and separate from other projects.\nLet’s create a new project now.\n\nGo to File &gt; New Project\nIn Create project from menu choose Existing Directory\nBrowse to Desktop &gt; Session01_DataWrangling\nSelect the check box that says Open in New Session\n\n\n\n\n\n\n\nFollow Along at Home\n\n\n\n\n\nPosit (RStudio) Cloud is a browser-based version of RStudio. It will allow you to use RStudio without needing to download anything to your computer. Posit Cloud automatically organizes things into Projects. You can also easily share your R projects with others.\nGet Started:\n\nCreate your free RStudio Cloud account at https://posit.cloud/plans/free.\nGo to the class project https://posit.cloud/content/8458222\nNote the text that marks this as a Temporary Copy. Select the Save a Permanent Copy button to begin working!"
  },
  {
    "objectID": "01-DataWrangling.html#r-scripts",
    "href": "01-DataWrangling.html#r-scripts",
    "title": "Data Wrangling with R",
    "section": "R Scripts",
    "text": "R Scripts\nA script is a text file in which you write your code. R scripts are generally recognized by the .R file extension. Scripts make it easy to re-run that code when you need to. In addition to code, your script can also have comments, which start with a # symbol. These comments make your script more human readable, but are ignored by the computer.\nTo get started in this lesson - open up the script in your RStudio Project called 01_DataWrangling.R"
  },
  {
    "objectID": "01-DataWrangling.html#welcome-to-the-tidyverse",
    "href": "01-DataWrangling.html#welcome-to-the-tidyverse",
    "title": "Data Wrangling with R",
    "section": "Welcome to the Tidyverse",
    "text": "Welcome to the Tidyverse\nIn this lesson, we will be using a group of packages which are part of what is known as the tidyverse - “an opinionated collection of R packages designed for data science. All packages share an underlying design philosophy, grammar, and data structures.”1, developed by Hadley Wickham.\n\n\n\n\n\n\nWhat is a package?\n\n\n\nAs mentioned above, R is extensible and packages are the way to extend the base functionality of R. Each package is a collection of functions, code, data, and documentation. Packages are specialized to accomplish a particular set of tasks. Users can easily install packages from package repositories, such as the central repository CRAN (Comprehensive R Archive Network) and Bioconductor, an important source of bioinformatics packages.\nThe sheer number of R packages can seem overwhelming to a beginner and a common question we hear is, “But how do I know what package to use?”. One place is to start is to take a look at CRAN Task Views, which organizes packages by topic. You can also try an internet search like “How do I do X in R” and this will typically lead you to solutions that mention packages you need to accomplish the task.\nOne reason we are focusing on the tidyverse packages in this class is because they are so versatile and might be the only packages you need for much of what you want to do in R.\n\n\nThe tidyverse packages we will be using include:\n\nreadr for importing data into R\ndplyr for handling common data wrangling tasks for tabular data\ntidyr which enables you to swiftly convert between different data formats (long vs. wide) for plotting and analysis\nlubridate for working with dates\nggplot2 for visualizing data (we’ll explore this package in the next session).\n\nFor the full list of tidyverse packages and documentation visit tidyverse.org You can install these packages individually, or you can install the entire tidyverse in one go."
  },
  {
    "objectID": "01-DataWrangling.html#installing-and-loading-packages",
    "href": "01-DataWrangling.html#installing-and-loading-packages",
    "title": "Data Wrangling with R",
    "section": "Installing and loading packages",
    "text": "Installing and loading packages\nWhen you first install R on your computer, it comes with a set of built-in packages and functions collectively referred to as Base R. To add additional packages, you must first install that package, and then load it into your current session. If you are taking this workshop in person at the library, or using the class Posit Cloud project, the tidyverse has already been installed, so we just need to load it. You only need to install a package once on a system, but you will load it each time you start a new r session. If the package had not already been installed, we would install with a function called install.packages().\n\n#install tidyverse if you haven't yet\n#install.packages(\"tidyverse\")\n\n#load tidyverse\nlibrary(tidyverse)"
  },
  {
    "objectID": "01-DataWrangling.html#functions",
    "href": "01-DataWrangling.html#functions",
    "title": "Data Wrangling with R",
    "section": "Functions",
    "text": "Functions\ninstall.packages() and library() are two examples of functions. Functions are one of the most important components of R code. A function is like a canned script. It usually takes some inputs, called arguments inside the parentheses that follow the name of the function, performs one or more tasks, and often returns some kind of output. The library() function takes the name of the package to load as it’s argument.\nHow do you know what arguments a function takes? For that you need to turn to the documentation of a particular package, or from within RStudio you can look up a function with ?function-name. Let’s try it with the library() function.\n\n?library\n\nThis opens the help pane in the lower right corner of RStudio. The documentation provides you with all the arguments and any default values, along with explanations of the arguments. Here we see that the the library function has the argument package with no defaults."
  },
  {
    "objectID": "01-DataWrangling.html#what-is-tidy-data",
    "href": "01-DataWrangling.html#what-is-tidy-data",
    "title": "Data Wrangling with R",
    "section": "What is Tidy Data?",
    "text": "What is Tidy Data?\nThe tidyverse is so named from the concept of “tidy data”. Data is considered “tidy” if it follows three rules:\n\nEach column is a variable\nEach row is an observation\nEach cell is a single value2\n\nData “in the wild” often isn’t tidy, but the tidyverse packages can help you create and analyze tidy datasets.\n\n\n\n\n\ntidy data structure3"
  },
  {
    "objectID": "01-DataWrangling.html#the-data-for-this-lesson",
    "href": "01-DataWrangling.html#the-data-for-this-lesson",
    "title": "Data Wrangling with R",
    "section": "The Data for This Lesson",
    "text": "The Data for This Lesson\nFor this lesson we will be using data which comes from Project Tycho - an open data project from the University of Pittsburgh which provides standardized datasets on numerous diseases to aid global health research.\nThroughout this lesson, we will be using a dataset from Project Tycho featuring historical counts of measles cases in the U.S.. We want to clean and present this data in a way that makes it easy to see how measles cases fluctuated over time.\nA useful feature of Project Tycho data is their use of a common set of variables. Read more about their data format."
  },
  {
    "objectID": "01-DataWrangling.html#importing-data",
    "href": "01-DataWrangling.html#importing-data",
    "title": "Data Wrangling with R",
    "section": "Importing data",
    "text": "Importing data\nNow,that the tidyverse is loaded, we can use it to import some data into our RStudio session. We are using a function from the readr package called read_csv(). This function takes as an argument the path to where the file is located. Let’s start by reading in measles_us file in the /data folder.\n\nread_csv(\"data/measles_us.csv\")\n\nRows: 422051 Columns: 15\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (11): ConditionName, PathogenName, CountryName, CountryISO, Admin1Name, ...\ndbl  (3): ConditionSNOMED, PartOfCumulativeCountSeries, CountValue\nlgl  (1): DiagnosisCertainty\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\n\n# A tibble: 422,051 × 15\n   ConditionName ConditionSNOMED PathogenName  CountryName CountryISO Admin1Name\n   &lt;chr&gt;                   &lt;dbl&gt; &lt;chr&gt;         &lt;chr&gt;       &lt;chr&gt;      &lt;chr&gt;     \n 1 Measles              14189004 Measles virus UNITED STA… US         WISCONSIN \n 2 Measles              14189004 Measles virus UNITED STA… US         WISCONSIN \n 3 Measles              14189004 Measles virus UNITED STA… US         WISCONSIN \n 4 Measles              14189004 Measles virus UNITED STA… US         WISCONSIN \n 5 Measles              14189004 Measles virus UNITED STA… US         WISCONSIN \n 6 Measles              14189004 Measles virus UNITED STA… US         WISCONSIN \n 7 Measles              14189004 Measles virus UNITED STA… US         WISCONSIN \n 8 Measles              14189004 Measles virus UNITED STA… US         WISCONSIN \n 9 Measles              14189004 Measles virus UNITED STA… US         WISCONSIN \n10 Measles              14189004 Measles virus UNITED STA… US         WISCONSIN \n# ℹ 422,041 more rows\n# ℹ 9 more variables: Admin1ISO &lt;chr&gt;, Admin2Name &lt;chr&gt;, CityName &lt;chr&gt;,\n#   PeriodStartDate &lt;chr&gt;, PeriodEndDate &lt;chr&gt;,\n#   PartOfCumulativeCountSeries &lt;dbl&gt;, DiagnosisCertainty &lt;lgl&gt;,\n#   SourceName &lt;chr&gt;, CountValue &lt;dbl&gt;\n\n\nBut doing this just gives us a preview of the data in the console. To really use the data, we need to assign it to an object. An object is like a container for a numerical value, string, data set, image, and much more. Just about everything in R is an object. You might liken them to variables in other programming languages or in math. We create an object, by giving our data a name and use the assignment operator, which looks like an arrow &lt;-. You can manually type in the lesser than sign &lt; and hyphen -, or use the keyboard shortcut Alt + -.\nLet’s call our new object measles_us. Object names should be short and easy to understand. They can’t have spaces, so you’ll want to separate multiple words with a underscore, or by using camel case. Object names also need to start with a letter not a number, and it’s best to avoid using names of common functions.\n\nmeasles_us &lt;- read_csv(\"data/measles_us.csv\")\n\nWhen you create an object, it shows up in your environment pane (the upper right panel). If we check our environment pane, we should now see an object called measles_us.\nLet’s do the same for the states.csv file.\n\nstates &lt;- read_csv(file = \"data/states.csv\")\n\nRows: 50 Columns: 3\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (3): name, division, region\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message."
  },
  {
    "objectID": "01-DataWrangling.html#exploring-and-summarizing-data",
    "href": "01-DataWrangling.html#exploring-and-summarizing-data",
    "title": "Data Wrangling with R",
    "section": "Exploring and Summarizing data",
    "text": "Exploring and Summarizing data\nData wrangling, also known as data cleaning or data munging, involves preparing raw data for analysis by transforming it into a more useful format. This process includes detecting and correcting errors, handling missing values, and reorganizing data for analysis. Using the tidyverse, we can streamline these tasks efficiently. After importing the data, you’ll typically start by exploring it, identifying patterns, and making necessary adjustments to prepare it for visualization and further analysis. This foundational step ensures that your data is accurate, consistent, and ready for insightful exploration.\n\nVectors and Data Frames and Tibbles oh my!\nFirst, it’s important to understand the type of object we just created. In R, tabular data like you find in a spreadsheet is stored in a data frame, one of the fundamental data structures in R. A data frame is a rectangular, two-dimensional data structure. That is, it has both columns and rows. Data frames can store multiple data types, such as numeric, character, and logical data, also known as classes.\nA tibble is a tidyverse version of the standard R data frame. For our purposes, the differences are minor enough that we can generally use the terms interchangeably, but to be precise, we will be working with tibbles in this lesson. All tibbles are data frames, but not all data frames are tibbles.\nAnother important R data structure is a vector. A vector is a one-dimensional data structure. That is, it is simply a sequence of elements. A vector can have only one data type. Data frames are created from multiple vectors, that is, each column in a data frame is a vector of the same length.\n\n\nBase R functions for exploring data\nView() opens the data as a file in your documents pane.This is a good way to see the data in a familiar spreadsheet-like format.\n\nView(measles_us)\n\nUse summary() to look at each column and find the data type and interquartile range for numeric data.\n\nsummary(measles_us)\n\n\n\n\n\n\n\nMissing data\n\n\n\n\n\nSometimes we get data with a large number of missing values. It can be helpful to know where data is missing before attempting to do any further analysis. R uses NA to indicate missing values. We can use the function is.na() to test for the presence of NAs in our data.is.na() will return a vector of values TRUE or FALSE. TRUE if the value is NA, FALSE if it is not. When we examined our data with the View function, we might have noticed that the first several values in Admin2Name column are missing (NA). We might want to know how many missing values total are in that column.\n\nis.na(measles_us$Admin2Name)\n\nAfter running this code you should see TRUE printed out repeatedly in the console. R is running through that column and printing TRUE whenever it runs into a missing value. But this still does not help us get the total number of NAs. To do that we need to nest the above code in another function sum().\n\nsum(is.na(measles_us$Admin2Name))\n\n[1] 198104\n\n\nsum() treats each each TRUE as a 1 and each FALSE as a 0. In that column there are 198104 out of 422051\nBut, if you have a lot of variables (columns), it would be a pain to do this for each one. So instead we can use a similar function colSums\n\ncolSums(is.na(measles_us))\n\n              ConditionName             ConditionSNOMED \n                          0                           0 \n               PathogenName                 CountryName \n                          0                           0 \n                 CountryISO                  Admin1Name \n                          0                           0 \n                  Admin1ISO                  Admin2Name \n                          0                      198104 \n                   CityName             PeriodStartDate \n                     198104                           0 \n              PeriodEndDate PartOfCumulativeCountSeries \n                          0                           0 \n         DiagnosisCertainty                  SourceName \n                     422051                           0 \n                 CountValue \n                          0 \n\n\n\n\n\n\n\ntidyverse functions for exploring data\nThe glimpse() function which is part of the tidyverse package tibble, lets you see the column names and data types clearly.\n\nglimpse(measles_us)\n\ndistinct() returns the distinct rows in a tibble. It can be used on a column to return the distinct values in that column. The first argument you supply is the tibble object. Subsequent arguments include the variables you want to count.\n\ndistinct(measles_us, ConditionName)\n\n# A tibble: 1 × 1\n  ConditionName\n  &lt;chr&gt;        \n1 Measles      \n\n\n\ndistinct(measles_us, Admin1Name)\n\n# A tibble: 56 × 1\n   Admin1Name\n   &lt;chr&gt;     \n 1 WISCONSIN \n 2 OHIO      \n 3 MICHIGAN  \n 4 NEVADA    \n 5 NEW JERSEY\n 6 WASHINGTON\n 7 DELAWARE  \n 8 KENTUCKY  \n 9 WYOMING   \n10 INDIANA   \n# ℹ 46 more rows\n\n\ncount() is similar to distinct() but also returns the number of observations (i.e. rows) for each of those distinct values. The first argument you supply is the tibble object. Subsequent arguments include the variables you want to count.\n\n count(measles_us, Admin1Name) \n\n# A tibble: 56 × 2\n   Admin1Name               n\n   &lt;chr&gt;                &lt;int&gt;\n 1 ALABAMA               7458\n 2 ALASKA                1869\n 3 AMERICAN SAMOA         118\n 4 ARIZONA               4685\n 5 ARKANSAS              5643\n 6 CALIFORNIA           14354\n 7 COLORADO              8042\n 8 CONNECTICUT          10816\n 9 DELAWARE              4507\n10 DISTRICT OF COLUMBIA  5027\n# ℹ 46 more rows\n\n\n\n\n\n\n\n\nMake code flow with the pipe %&gt;%\n\n\n\nBefore we go any further - I want to introduce you to an important time-saving symbol in R called the pipe %&gt;% (CTRL + SHIFT + M). The pipe allows you to take the output of the left-hand expression and make it the input of the right-hand expression. It allows you to chain together multiple functions and avoid nesting. With the pipe, we can rewrite the above code as follows:\n\nmeasles_us %&gt;% \n  count(Admin1Name)\n\n# A tibble: 56 × 2\n   Admin1Name               n\n   &lt;chr&gt;                &lt;int&gt;\n 1 ALABAMA               7458\n 2 ALASKA                1869\n 3 AMERICAN SAMOA         118\n 4 ARIZONA               4685\n 5 ARKANSAS              5643\n 6 CALIFORNIA           14354\n 7 COLORADO              8042\n 8 CONNECTICUT          10816\n 9 DELAWARE              4507\n10 DISTRICT OF COLUMBIA  5027\n# ℹ 46 more rows\n\n\nIn many tidyverse functions, the first argument is the name of the data frame you’re applying the function to. So when you use the pipe, you’ll generally start a line of code with the name of a tibble. One benefit you might notice right away, is that when we use the pipe, RStudio will supply the column names which helps to reduce typing and typos.\n\n\n\n\n\n\n\n\nCHALLENGE\n\n\n\nNow let’s try exploring the states tibble in our environment\n\nUse glimpse() to inspect the columns and data types in the dataset.\nUse distinct() to find out the distinct values in the region column.\nUsing count(), find out how many states are in each region.\nUsing count(), find out how many states are in each region AND division. HINT: You can add additional column names to distinct() and count() to look at combinations of columns."
  },
  {
    "objectID": "01-DataWrangling.html#subsetting-data-with-select-and-filter",
    "href": "01-DataWrangling.html#subsetting-data-with-select-and-filter",
    "title": "Data Wrangling with R",
    "section": "Subsetting data with select() and filter()",
    "text": "Subsetting data with select() and filter()\nReal data sets can be quite large. So, once you’ve explored your data, you may want to start trimming it down to just the variables and conditions you’re interested in. In this section, we’ll look at two functions from the tidyverse package called dplyr: select() which lets you choose columns (variables) and filter() which lets you choose rows. (Note: dplyr is known for using easy to understand verbs for its function names.)\n\nselect()\nselect() lets you choose columns by name. The syntax of this function is similar to the the ones we’ve already learned count() and distinct(). We need to supply the function with the name of the tibble and the columns. This will create a new tibble with just those columns.\nAs with all tidyverse functions, we can use %&gt;% to make this easier.\n\nmeasles_us %&gt;% \nselect(Admin1Name, CountValue)\n\n# A tibble: 422,051 × 2\n   Admin1Name CountValue\n   &lt;chr&gt;           &lt;dbl&gt;\n 1 WISCONSIN          85\n 2 WISCONSIN         120\n 3 WISCONSIN          84\n 4 WISCONSIN         106\n 5 WISCONSIN          39\n 6 WISCONSIN          45\n 7 WISCONSIN          28\n 8 WISCONSIN         140\n 9 WISCONSIN          48\n10 WISCONSIN          85\n# ℹ 422,041 more rows\n\n\nIf you want to select several columns that are next to each other, you can use : to specify a range, rather than writing each name out separately.\n\nmeasles_us %&gt;% \nselect( ConditionName:Admin1ISO)\n\n# A tibble: 422,051 × 7\n   ConditionName ConditionSNOMED PathogenName  CountryName CountryISO Admin1Name\n   &lt;chr&gt;                   &lt;dbl&gt; &lt;chr&gt;         &lt;chr&gt;       &lt;chr&gt;      &lt;chr&gt;     \n 1 Measles              14189004 Measles virus UNITED STA… US         WISCONSIN \n 2 Measles              14189004 Measles virus UNITED STA… US         WISCONSIN \n 3 Measles              14189004 Measles virus UNITED STA… US         WISCONSIN \n 4 Measles              14189004 Measles virus UNITED STA… US         WISCONSIN \n 5 Measles              14189004 Measles virus UNITED STA… US         WISCONSIN \n 6 Measles              14189004 Measles virus UNITED STA… US         WISCONSIN \n 7 Measles              14189004 Measles virus UNITED STA… US         WISCONSIN \n 8 Measles              14189004 Measles virus UNITED STA… US         WISCONSIN \n 9 Measles              14189004 Measles virus UNITED STA… US         WISCONSIN \n10 Measles              14189004 Measles virus UNITED STA… US         WISCONSIN \n# ℹ 422,041 more rows\n# ℹ 1 more variable: Admin1ISO &lt;chr&gt;\n\n\nNow, let’s think through which columns we want for our analysis and save this to a new object called measles_select. It’s always a good idea to create new objects when you make major changes to your data.\nFor this exercise, we want to look at trends in number of measles cases over time. To do that, we’ll need to keep our CountValue variable, as and the date variables (PeriodStartDate and PeriodEndDate), as well as the PartOfCumulativeCountSeries variable, which will help us understand how to use the dates (more on this later). The first five columns each have only one value. So it might be redundant to keep those, although if we were combining them with other Project Tycho datasets they could be useful. It might be interesting to get a state-level view of the data, so let’s keep Admin1Name. But we saw that there are a number of missing values in our Admin2Name and CityName variables, so they might not be very useful for our analysis.\n\nmeasles_select &lt;-\n  measles_us %&gt;%\n    select(\n     Admin1Name,\n     PeriodStartDate,\n     PeriodEndDate,\n     PartOfCumulativeCountSeries,\n     CountValue\n)\n\nSometimes when receive a data set or start working with data, you may find that the column names are overly long or not very descriptive or useful, and it may be necessary to rename them. For this, we can use the rename() function. Like naming objects, you should use a simple, descriptive, relatively short name without spaces for your column names. Let’s rename Admin1Name to State to make that more meaningful to us. rename() has the syntax rename(newColumnName = OldColumnName).\n\nmeasles_select &lt;-\n  measles_select %&gt;% \n    rename(state = Admin1Name)\n\nNote that in this case, we are overwriting our original object with the new name instead of creating a new one!\n\n\nfilter()\nWhile select() acts on columns, filter() acts on rows. filter() takes the name of the tibble and one or more logical conditions as arguments.\n\nmeasles_md &lt;- measles_select %&gt;% \n  filter(state == \"MARYLAND\")\n\nHere we are saying keep all the rows where the value in the state column is “MARYLAND”. Note the use of the double equals sign == versus the singular = sign. The double equal sign is a logical operator. The logical operators are:\n\n\n\noperator\nmeaning\n\n\n\n\n==\nexactly equal\n\n\n!=\nnot equal to\n\n\n&lt;\nless than\n\n\n&lt;=\nless than or equal to\n\n\n&gt;\ngreater than\n\n\n&gt;=\ngreater than or equal to\n\n\nx|y\nx or y\n\n\nx&y\nx and y\n\n\n!x\nnot x\n\n\n\nNote that after running our code, our resulting tibble (our new object measles_md) has 7246 observations (rows) while our original tibble had 422051.\n\n\n\n\n\n\nWarning\n\n\n\nWhen matching strings you must be exact. R is case-sensitive. So state == \"Maryland\" or state == \"maryland\" would return 0 rows.\n\n\nYou can add additional conditions to filter by, separated other logical operators like &, &gt;, and &gt;.\nBelow we want just the rows for Maryland, and only include periods where the count was more than 500 reported cases. Note that while you need quotation marks around character data, you do not need them around numeric data.\n\nmeasles_select %&gt;%\n  filter(state == \"MARYLAND\" & CountValue &gt; 500)\n\n# A tibble: 328 × 5\n   state    PeriodStartDate PeriodEndDate PartOfCumulativeCountSeries CountValue\n   &lt;chr&gt;    &lt;chr&gt;           &lt;chr&gt;                               &lt;dbl&gt;      &lt;dbl&gt;\n 1 MARYLAND 1/29/1928       2/4/1928                                0        504\n 2 MARYLAND 2/5/1928        2/11/1928                               0        563\n 3 MARYLAND 2/12/1928       2/18/1928                               0        696\n 4 MARYLAND 2/19/1928       2/25/1928                               0        750\n 5 MARYLAND 2/26/1928       3/3/1928                                0       1012\n 6 MARYLAND 3/4/1928        3/10/1928                               0        951\n 7 MARYLAND 3/11/1928       3/17/1928                               0       1189\n 8 MARYLAND 3/18/1928       3/24/1928                               0       1163\n 9 MARYLAND 3/25/1928       3/31/1928                               0       1020\n10 MARYLAND 4/1/1928        4/7/1928                                0        753\n# ℹ 318 more rows\n\n\nHere, we joined together 2 conditions with the & logical operator. Then we piped that resulting tibble to count() which remember takes a tibble as its first argument.\nWhat if we wanted to filter our tibble to include just the 50 states and no territories? We sure would not have to write out an expression for each state, or even all the territories.\n\n# we can avoid verbose code like this with %in%\n\nmeasles_select %&gt;% \nfilter(state == \"MARYLAND\" & state == \"DELAWARE\" & state == \"Pennsylvania\")\n\n# A tibble: 0 × 5\n# ℹ 5 variables: state &lt;chr&gt;, PeriodStartDate &lt;chr&gt;, PeriodEndDate &lt;chr&gt;,\n#   PartOfCumulativeCountSeries &lt;dbl&gt;, CountValue &lt;dbl&gt;\n\n\nLuckily, We can filter based on a vector of values with the %in% operator (remember we can think of a vector as a column of data). So, we can write some code to filter our data based on list of state names in our states tibble.\n\nmeasles_states_only &lt;-\n  measles_select %&gt;% \n  filter(state %in% states$name)\n\nLet’s save this output to a new object measles_states_only. Notice how we now have fewer rows than we had in our measles_select object.\nWe could alternatively have used negation with the names of the values we specifically wanted to exclude.\n\nmeasles_states_only &lt;- measles_select %&gt;% \n  filter(!state %in% c(\"PUERTO RICO\", \"GUAM\", \"AMERICAN SAMOA\", \"NORTHERN MARIANA ISLANDS\", \"VIRGIN ISLANDS, U.S.\", \"DISTRICT OF COLUMBIA\"))\n\nGreat! Our dataset is really shaping up. Let’s also take a closer look at our date columns. If you look at the first several rows, it looks like each row of our dataset represents about a discrete week of measles case counts. But (as you can read in the Tycho data documentation) there are actually two date series in this dataset - non-cumulative and cumulative. Which series a row belongs to is noted by the PartofCumulativeCountSeries, which as the value 0 if a row is non-cumulative, and 1 if the row is part of a cumulative count.\nTo keep things consistent. Let’s filter our tibble so we only have the non-overlapping discrete weeks.\n\nmeasles_non_cumulative &lt;- \n  measles_states_only %&gt;% \n  filter(PartOfCumulativeCountSeries==0)\n\nOnce again, we have fewer rows than we started with.\n\n\n\n\n\n\nCHALLENGE\n\n\n\n\nUse select() to create a new tibble with just the name and division columns from the states tibble. Assign this to an object called us_divisions.\nUse filter() to keep just the rows in the South Atlantic division of the us_divisions tibble. Assign this to an object called sa_division.\nUse filter() to keep just the rows in the measles_non_cumulative tibble where the state matches one of the states in the name column of the sa_division tibble and where the CountValue is greater than 1000. Assign this to an object called measles_sa.\n\n\n\nNow let’s do some more with our date variables."
  },
  {
    "objectID": "01-DataWrangling.html#changing-and-creating-variables-with-mutate",
    "href": "01-DataWrangling.html#changing-and-creating-variables-with-mutate",
    "title": "Data Wrangling with R",
    "section": "Changing and creating variables with mutate()",
    "text": "Changing and creating variables with mutate()\nLet’s review the columns in our measles_states_only tibble\n\nglimpse(measles_non_cumulative)\n\nRows: 332,138\nColumns: 5\n$ state                       &lt;chr&gt; \"WISCONSIN\", \"WISCONSIN\", \"WISCONSIN\", \"WI…\n$ PeriodStartDate             &lt;chr&gt; \"11/20/1927\", \"11/27/1927\", \"12/4/1927\", \"…\n$ PeriodEndDate               &lt;chr&gt; \"11/26/1927\", \"12/3/1927\", \"12/10/1927\", \"…\n$ PartOfCumulativeCountSeries &lt;dbl&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, …\n$ CountValue                  &lt;dbl&gt; 85, 120, 84, 106, 39, 45, 28, 140, 48, 85,…\n\n\nWe can see from this that the dates are being interpreted as character data. We want R to recognize them as dates. We can create new variables and adjust existing variables with the mutate() function.\nmutate() takes as an argument the name and definition of the new column you’re creating. Note that if you use the same variable name as an existing variable name it overwrites that column. Otherwise, it will add a column to your tibble.\nTo change the variable to a date - we are using a date parsing function from another package called lubridate. mdy() takes a character string or number in month-day-year format (as we have here) and returns a formal date object in YYYY-MM-DD format. There are similar functions if the input date is in year-month-day ydm() or day-month-year dmy()\n\nmeasles_non_cumulative &lt;- measles_non_cumulative %&gt;% \nmutate(PeriodStartDate = mdy(PeriodStartDate),\n       PeriodEndDate = mdy(PeriodEndDate))\n\nNote that you can mutate multiple columns at a time, separating each new column definition with a comma.\nNow that R recognizes the date columns as Dates, we can do things like extract parts of the date, such as the year. Let’s create a separate Year column. Later we’ll be able to group our tibble by year for analysis.\n\nmeasles_year &lt;- \n  measles_non_cumulative %&gt;% \n  mutate(Year=year(PeriodStartDate))"
  },
  {
    "objectID": "01-DataWrangling.html#grouping-and-summarizing",
    "href": "01-DataWrangling.html#grouping-and-summarizing",
    "title": "Data Wrangling with R",
    "section": "Grouping and Summarizing",
    "text": "Grouping and Summarizing\nMany data analysis tasks can be approached using the split-apply-combine paradigm: split the data into groups, apply some analysis to each group, and then combine the results. dplyr makes this very easy through the use of the group_by() function.\ngroup_by() is often used together with summarize(), which collapses each group into a single-row summary of that group. group_by() takes as arguments the column names that contain the categorical variables for which you want to calculate the summary statistics.\nHow can we calculate the total number of measles cases for each year?\nFirst we need to group our data by year using our new Year column.\n\nyearly_count &lt;-\n  measles_year %&gt;%\n  group_by(Year)\n\nyearly_count\n\n# A tibble: 332,138 × 6\n# Groups:   Year [96]\n   state   PeriodStartDate PeriodEndDate PartOfCumulativeCoun…¹ CountValue  Year\n   &lt;chr&gt;   &lt;date&gt;          &lt;date&gt;                         &lt;dbl&gt;      &lt;dbl&gt; &lt;dbl&gt;\n 1 WISCON… 1927-11-20      1927-11-26                         0         85  1927\n 2 WISCON… 1927-11-27      1927-12-03                         0        120  1927\n 3 WISCON… 1927-12-04      1927-12-10                         0         84  1927\n 4 WISCON… 1927-12-18      1927-12-24                         0        106  1927\n 5 WISCON… 1927-12-25      1927-12-31                         0         39  1927\n 6 WISCON… 1928-01-01      1928-01-07                         0         45  1928\n 7 WISCON… 1928-01-08      1928-01-14                         0         28  1928\n 8 WISCON… 1928-01-15      1928-01-21                         0        140  1928\n 9 WISCON… 1928-01-22      1928-01-28                         0         48  1928\n10 WISCON… 1928-01-29      1928-02-04                         0         85  1928\n# ℹ 332,128 more rows\n# ℹ abbreviated name: ¹​PartOfCumulativeCountSeries\n\n\nWhen you inspect your new tibble, everything should look the same. Grouping prepares your data for summarize, but it does not do anything visually to the data.\nNow let’s trying summarizing that data. summarize() condenses the value of the group values to a single value per group. Like mutate(), we provide the function with the name of the new column that will hold the summary information. In this case, we will use the sum() function on the CountValue column and put this in a new column called TotalCount. Summarize will drop the columns that aren’t being used.\n\nyearly_count &lt;-\n  measles_year %&gt;%\n  group_by(Year) %&gt;%\n  summarise(TotalCount = sum(CountValue))\n\nyearly_count\n\n# A tibble: 96 × 2\n    Year TotalCount\n   &lt;dbl&gt;      &lt;dbl&gt;\n 1  1906       2345\n 2  1907      40199\n 3  1908      54471\n 4  1909      49802\n 5  1910      86984\n 6  1911      59171\n 7  1912      64773\n 8  1913     111431\n 9  1914      56440\n10  1915      93579\n# ℹ 86 more rows\n\n\nA more useful view might be to look for yearly totals of case counts by state. We can group by two variables, Year, and then State.\n\nyearly_count_state &lt;-\n  measles_year %&gt;%\n  group_by(Year, state) %&gt;%\n  summarise(TotalCount = sum(CountValue))\n\n`summarise()` has grouped output by 'Year'. You can override using the\n`.groups` argument.\n\nyearly_count_state\n\n# A tibble: 4,055 × 3\n# Groups:   Year [96]\n    Year state         TotalCount\n   &lt;dbl&gt; &lt;chr&gt;              &lt;dbl&gt;\n 1  1906 CALIFORNIA           224\n 2  1906 CONNECTICUT           23\n 3  1906 FLORIDA                4\n 4  1906 ILLINOIS             187\n 5  1906 INDIANA               20\n 6  1906 KENTUCKY               2\n 7  1906 MAINE                 26\n 8  1906 MASSACHUSETTS        282\n 9  1906 MICHIGAN             320\n10  1906 MISSOURI             274\n# ℹ 4,045 more rows\n\n\nNotice how the use of pipes really comes in handy here. It saved us from having to create and keep track of a number of intermediate objects."
  },
  {
    "objectID": "01-DataWrangling.html#sorting-datasets-with-arrange",
    "href": "01-DataWrangling.html#sorting-datasets-with-arrange",
    "title": "Data Wrangling with R",
    "section": "Sorting datasets with arrange()",
    "text": "Sorting datasets with arrange()\nWhich state in which year had the highest case count? To easily find out, we can use the function arrange(). One of the arguments must be the column you want to sort on.\n\nyearly_count_state %&gt;% arrange(TotalCount)\n\n# A tibble: 4,055 × 3\n# Groups:   Year [96]\n    Year state       TotalCount\n   &lt;dbl&gt; &lt;chr&gt;            &lt;dbl&gt;\n 1  1925 NEVADA               0\n 2  1937 MISSISSIPPI          0\n 3  1938 MISSISSIPPI          0\n 4  1939 MISSISSIPPI          0\n 5  1940 MISSISSIPPI          0\n 6  1940 NEVADA               0\n 7  1941 MISSISSIPPI          0\n 8  1944 MISSISSIPPI          0\n 9  1945 MISSISSIPPI          0\n10  1906 TEXAS                1\n# ℹ 4,045 more rows\n\n\nBy default, arrange sorts in ascending order. To sort by descending order we use together with the desc() function.\n\nyearly_count_state %&gt;% arrange(desc(TotalCount))\n\n# A tibble: 4,055 × 3\n# Groups:   Year [96]\n    Year state        TotalCount\n   &lt;dbl&gt; &lt;chr&gt;             &lt;dbl&gt;\n 1  1938 PENNSYLVANIA     146467\n 2  1941 PENNSYLVANIA     137180\n 3  1938 ILLINOIS         127935\n 4  1942 CALIFORNIA       116180\n 5  1941 OHIO             114788\n 6  1935 MICHIGAN         111413\n 7  1941 NEW YORK         109663\n 8  1938 MICHIGAN         109041\n 9  1934 PENNSYLVANIA     107031\n10  1938 WISCONSIN        104450\n# ℹ 4,045 more rows"
  },
  {
    "objectID": "01-DataWrangling.html#joining-datasets",
    "href": "01-DataWrangling.html#joining-datasets",
    "title": "Data Wrangling with R",
    "section": "Joining Datasets",
    "text": "Joining Datasets\nOf course, looking at total counts in each state is not the most helpful metric without taking population into account. To rectify this, let’s try joining some historical population data with our measles data.\nFirst we need to import the population data4.\n\nhist_pop &lt;-\n  read_csv(\"data/Historical_Population_by_State.csv\")\n\nRows: 107 Columns: 52\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\ndbl (52): DATE, ALASKA, ALABAMA, ARKANSAS, ARIZONA, CALIFORNIA, COLORADO, CO...\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\n\n\nLong vs Wide formats\nRemember that for data to be considered “tidy”, it should be in what is called “long” format. Each column is a variable, each row is an observation, and each cell is a value. Our state population data is in “wide” format, because State Name is being treated as a variable, when it is really a value. Wide data is often preferable for human-readability, but is less ideal for machine-readability. To be able to join this data to our measles dataset, it needs to have 3 columns - Year, State Name, and Population.\nWe will use the package tidyr and the function pivot_longer to convert our population data to a long format, thus making it easier to join with our measles data.\nEach column in our population dataset represents a state. To make it tidy we are going to reduce those to one column called State with the state names as the values of the column. We will then need to create a new column for population containing the current cell values. To remember that the population data is provided in 1000s of persons, we will call this new column pop1000.\npivot_longer() takes four principal arguments:\n\nthe data\ncols are the names of the columns we use to fill the new values variable (or to drop).\nthe names_to column variable we wish to create from the cols provided.\nthe values_to column variable we wish to create and fill with values associated with the cols provided.\n\n\nlibrary(tidyr)\nhist_pop_long &lt;- hist_pop %&gt;%\n  pivot_longer(ALASKA:WYOMING,\n               names_to = \"state\",\n               values_to = \"pop1000\")\n\n\nView(hist_pop_long)\n\nNow our two datasets have similar structures, a column of state names, a column of years, and a column of values. Let’s join these two datasets by the state and year columns. Note that if both sets have the same column names, you do not need to specify anything in the by argument. We use a left join here which preserves all the rows in our measles dataset and adds the matching rows from the population dataset.\n\nmeasles_joined&lt;- yearly_count_state %&gt;% \n  left_join(hist_pop_long, by=join_by(state, Year == DATE))\n\nmeasles_joined\n\n# A tibble: 4,055 × 4\n# Groups:   Year [96]\n    Year state         TotalCount pop1000\n   &lt;dbl&gt; &lt;chr&gt;              &lt;dbl&gt;   &lt;dbl&gt;\n 1  1906 CALIFORNIA           224    1976\n 2  1906 CONNECTICUT           23    1033\n 3  1906 FLORIDA                4     628\n 4  1906 ILLINOIS             187    5309\n 5  1906 INDIANA               20    2663\n 6  1906 KENTUCKY               2    2234\n 7  1906 MAINE                 26     729\n 8  1906 MASSACHUSETTS        282    3107\n 9  1906 MICHIGAN             320    2626\n10  1906 MISSOURI             274    3223\n# ℹ 4,045 more rows\n\n\n\n\n\n\n\n\nCHALLENGE\n\n\n\n\nUse mutate() to calculate the rate of measles per 100,000 persons (remember population is given in 1000s).\nTry joining measles_yearly_rates to states. What variable do you need to join by?\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\n# 1. \nmeasles_yearly_rates &lt;-\n  measles_joined %&gt;% \n  mutate(epi_rate = (TotalCount / pop1000)*1000)\n\n# 2. \nyearly_rates_joined &lt;- measles_yearly_rates %&gt;% \n  left_join(states, by = join_by(state == name))\n\n\n\n\n\n\nNow our data is ready to be visualized!"
  },
  {
    "objectID": "01-DataWrangling.html#footnotes",
    "href": "01-DataWrangling.html#footnotes",
    "title": "Data Wrangling with R",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nhttps://www.tidyverse.org/↩︎\nread more about tidy data https://cran.r-project.org/web/packages/tidyr/vignettes/tidy-data.html↩︎\nimage from R for Data Science https://r4ds.had.co.nz/tidy-data.html#fig:tidy-structure↩︎\npopulation data retrieved from the FRED, the Federal Reserve Bank of St. Louis Economic Data, https://fred.stlouisfed.org/release/tables?rid=118&eid=259194↩︎"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Data Wrangling and Visualization in R",
    "section": "",
    "text": "Session 1: Data Wrangling This session will introduce participants to the basics of getting started with R and RStudio and introduce the workhorse package dplyr. Participants will get hands-on experience wrangling real data sets.\nTopics covered include:\n\nNavigating RStudio\nKey R concepts and terminology\nImporting data from external files\nSubsetting and filtering data\nSplit-Apply-Combine analysis workflow\n\nSession 2: Data Visualization Learn how to use ggplot2, a robust Tidyverse package used to create high quality graphics for exploring and communicating your data. We will go beyond basic graphs and learn how to customize and annotate our graphs for more effective storytelling. Participants will have the best experience if they attended session one in this series or have some previous experience with R and the Tidyverse.\nTopics covered include:\n\nVisualization best practices\nGrammar of graphics – ggplot2 layers, aesthetics, and geoms\nChoosing an effective graph type for your data\nCustomizing labels, axes, legends, and more\nChoosing a color palette and themes"
  },
  {
    "objectID": "index.html#course-description",
    "href": "index.html#course-description",
    "title": "Data Wrangling and Visualization in R",
    "section": "",
    "text": "Session 1: Data Wrangling This session will introduce participants to the basics of getting started with R and RStudio and introduce the workhorse package dplyr. Participants will get hands-on experience wrangling real data sets.\nTopics covered include:\n\nNavigating RStudio\nKey R concepts and terminology\nImporting data from external files\nSubsetting and filtering data\nSplit-Apply-Combine analysis workflow\n\nSession 2: Data Visualization Learn how to use ggplot2, a robust Tidyverse package used to create high quality graphics for exploring and communicating your data. We will go beyond basic graphs and learn how to customize and annotate our graphs for more effective storytelling. Participants will have the best experience if they attended session one in this series or have some previous experience with R and the Tidyverse.\nTopics covered include:\n\nVisualization best practices\nGrammar of graphics – ggplot2 layers, aesthetics, and geoms\nChoosing an effective graph type for your data\nCustomizing labels, axes, legends, and more\nChoosing a color palette and themes"
  },
  {
    "objectID": "index.html#license",
    "href": "index.html#license",
    "title": "Data Wrangling and Visualization in R",
    "section": "License",
    "text": "License\n“This material is shared under a CC-BY 4.0 license.”"
  },
  {
    "objectID": "02-DataVisualization.html#getting-set-up",
    "href": "02-DataVisualization.html#getting-set-up",
    "title": "Data Visualization with ggplot2",
    "section": "Getting set up",
    "text": "Getting set up\n\nGo to File &gt; New Project\nIn Create project from menu choose Existing Directory\nBrowse to Desktop &gt; Session02_DataVisualization\nSelect the check box that says Open in New Session\nOpen the companion script called 02-DataVisualization.R\nUse the library() function to load the tidyverse, viridis, and usmap packages.\nUse the read_csv() function to import the yearly_rates_joined and the region_summary csv files.\n\n\n\n\n\n\n\nFollow Along at Home\n\n\n\n\n\nPosit (RStudio) Cloud is a browser-based version of RStudio. It will allow you to use RStudio without needing to download anything to your computer. Posit Cloud automatically organizes things into Projects. You can also easily share your R projects with others.\nGet Started:\n\nCreate your free RStudio Cloud account at https://posit.cloud/plans/free if you haven’t already.\nGo to the class project https://posit.cloud/content/8458074\nNote the text that marks this as a Temporary Copy. Select the Save a Permanent Copy button to begin working!\n\n\n\n\n\nlibrary(tidyverse)\nlibrary(viridis)\nlibrary(usmap)\n\nyearly_rates_joined &lt;- read_csv(\"data/yearly_rates_joined.csv\")\n\nregion_summary &lt;- read_csv(\"data/region_summary.csv\")"
  },
  {
    "objectID": "02-DataVisualization.html#why-data-visualization",
    "href": "02-DataVisualization.html#why-data-visualization",
    "title": "Data Visualization with ggplot2",
    "section": "Why Data Visualization?",
    "text": "Why Data Visualization?\nVisualization is an important process which can help us explore, understand, analyze, and communicate about data. Visualizations, including many kinds of graphs, charts, maps, animations, and infographics, can be far more effective at quickly communicating important points than raw numbers alone. But visualizations also have the power to mislead. And so throughout this class, we’ll be covering some good data visualization practices. Slides accompanying this section can be found here: https://osf.io/yk5bx1"
  },
  {
    "objectID": "02-DataVisualization.html#visualizing-data-with-ggplot2",
    "href": "02-DataVisualization.html#visualizing-data-with-ggplot2",
    "title": "Data Visualization with ggplot2",
    "section": "Visualizing Data with ggplot2",
    "text": "Visualizing Data with ggplot2\nNext, we will learn about ggplot2 - a tidyverse package for visualizing data. It is a powerful and flexible R package that allows you to create fully customizable, publication quality graphics. The gg in ggplot2 stands for grammar of graphics. The grammar of graphics is the underlying philosophy of the package. It focuses on creating graphics in layers. Start with the data – map the data to the axes and to aesthetic qualities like size, shape, and color and geometries like dots, lines, and polygons. Further refine the appearance of your plot by adjusting scales and legends, labels, coordinate systems, and adding annotations.\nAll ggplot2 graphs start with the same basic template:\n&lt;DATA&gt; %&gt;%\n    ggplot(aes(&lt;MAPPINGS&gt;)) +\n    &lt;GEOM_FUNCTION&gt;() +\n    &lt;Additional GEOMS, SCALES, THEMES, etc. . . &gt;\n\nAll graphs start with the ggplot function and the data. We’ll use the pipe to pipe the data to the function.\n\nregion_summary %&gt;% \n  ggplot()\n\n\n\n\n\n\n\n\nWe see that even this initializes the plot area of RStudio.\nNext, we define a mapping (using the aesthetic, or aes(), function), by selecting the variables to be plotted and specifying how to present them in the graph, e.g. as x/y positions or characteristics such as size, shape, color, etc. Here we will say that the x axis should contain the affiliation variable. Note how the x-axis populates with some numbers and tick marks.\n\nregion_summary %&gt;%\n  ggplot(aes(x=region, y=avg_rate))\n\n\n\n\n\n\n\n\nNext we need to add ‘geoms’ – graphical representations of the data in the plot (points, lines, bars). ggplot2 offers many different geoms for common graph types. To add a geom to the plot use the + operator.\n\nregion_summary %&gt;%\n  ggplot(aes(x=region, y=avg_rate)) +\n           geom_bar(stat = \"identity\")\n\n\n\n\n\n\n\n\nIf you want the y axis to display something other than count, you need to make a couple of small adjustments. First - specify the y variable in the aes() function, and change the stat argument from it’s default of “count” to “identity” This tells it to base the y axis on the specified variable.\n\nSetting vs mapping aesthetics\nWhen working with ggplot2, it’s important to understand the difference between setting aesthetic properties and mapping them. All geoms have certain visual attributes that can be modified. Polygons like bars, have the properties fill and color. You can change the inside color of a bar with fill, and the border with color. We can modify the defaults with the fill and color arguments in the geom_bar() layer. (I’ve also increased the linewidth to make it easier to see the border color)\n\nregion_summary %&gt;%\n  ggplot(aes(x=region, y=avg_rate)) +\n           geom_bar(stat = \"identity\",\n                    fill=\"blue\",\n                    color=\"purple\",\n                    linewidth=1.5,\n                    width = 0.8)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nHow did we know the color names “blue” and “purple” would work in the code above? R has 657 (!!) built in color names. You can see them by calling the function colors(). You can also specify colors using rgb and hexadecimal codes.\n\n\nNow we have manually set a value for the fill and color. To create our initial graph, we used the mapping argument and the aes() function to map the x axis to the region`` variable. Watch what happens if we map the fill property to theregion` variable as well.\n\nregion_summary %&gt;%\n  ggplot(aes(x=region, y=avg_rate, fill=region)) +\n           geom_bar(stat = \"identity\")\n\n\n\n\n\n\n\n\nAs we’ll see later in this lesson, mapping a variable to an aesthetic will be especially helpful when we have a third variable to display.\n\n\n\n\n\n\nNote\n\n\n\nWhen you map an aesthetic with aes() in the ggplot() function it is inherited by all subsequent layers. When you map in a geom_*() function it is applied only to that layer.\n\n\nNow let’s start using ggplot2 to help us answer our research question - how did the introduction of the vaccine affect measles rates in the country? We’ll do this with a line graph, which is useful for showing change over time.\nFirst, we need to use our **dplyr** skills to summarize the data.\n\nyearly_rates_joined %&gt;% \n  group_by(Year) %&gt;% \n  summarize(TotalCount = sum(TotalCount))\n\n# A tibble: 96 × 2\n    Year TotalCount\n   &lt;dbl&gt;      &lt;dbl&gt;\n 1  1906       2345\n 2  1907      40199\n 3  1908      54471\n 4  1909      49802\n 5  1910      86984\n 6  1911      59171\n 7  1912      64773\n 8  1913     111431\n 9  1914      56440\n10  1915      93579\n# ℹ 86 more rows\n\n\nWe pipe to ggplot() and assign Year to the x-axis and TotalCount to the y-axis with the aes() function. The canvas and axes are ready.\n\nyearly_rates_joined %&gt;% \n  group_by(Year) %&gt;% \n  summarize(TotalCount = sum(TotalCount)) %&gt;% \n  ggplot(aes(x=Year, y=TotalCount))\n\n\n\n\n\n\n\n\nNow we can add a geom layer to add our line. Let’s also be sure to save our work to an object.\n\nyear_total_line &lt;- yearly_rates_joined %&gt;% \n  group_by(Year) %&gt;% \n  summarize(TotalCount = sum(TotalCount)) %&gt;% \n  ggplot(aes(x=Year, y=TotalCount)) + \n  geom_line()\n\nyear_total_line\n\n\n\n\n\n\n\n\nIt might be nice to see where each data point falls on the line. To do this we can add another geometry layer.\n\nyear_total_line &lt;- yearly_rates_joined %&gt;% \n  group_by(Year) %&gt;% \n  summarize(TotalCount = sum(TotalCount)) %&gt;% \n  ggplot(aes(x=Year, y=TotalCount)) + \n  geom_line() +\n  geom_point()\n\nyear_total_line\n\n\n\n\n\n\n\n\n\nThe + in the ggplot2 package is particularly useful because it allows you to modify existing ggplot objects. This means you can easily set up plot templates and conveniently explore different types of plots, so the above plot can also be generated with code like this:\nyear_total_line &lt;- year_total_line + geom_point()\n\nThere are many ways to customize your plot, like changing the color or line type, adding labels and annotations. One thing that would make our graph easier to read is tick marks at each decade on the x-axis. There are a number of functions in ggplot2 for altering the scale. We want to alter the x-axis scale, which holds continuous data, so we can use the scale_x_continuous() function. Note that when you start to write the name of the function, RStudio will supply you with other similarly named functions.\nscale_x_continuous() has an argument called breaks which allows you to alter where the axis tick marks occur. We can use that together with seq() to say put a tick mark every 10 places between 1900 and 2000.\n\nyear_total_line &lt;- yearly_rates_joined %&gt;% \n  group_by(Year) %&gt;% \n  summarize(TotalCount = sum(TotalCount)) %&gt;% \n  ggplot(aes(x=Year, y=TotalCount)) + \n  geom_line() +\n  geom_point() + \n  scale_x_continuous(breaks = seq(from=1900, to=2000, by=10))\n\nyear_total_line\n\n\n\n\n\n\n\n\nNow we can move beyond basic exploration and start to use our graph to analyze and tell stories about our data. One important trend we might notice, is the sharp decrease in cases in the 1960s. The measles vaccine was introduced in 1963. We can use our visualization to tell the story of the vaccine’s impact.\nLet’s drop a reference line at 1963 to clearly indicate on the graph when the vaccine was introduced. To do this we add a geom_vline() and the annotate() function. There are multiple ways of adding lines and text to a plot, but these will serve us well for this case. Note that you can change features of lines such as color, type, and size. We can supply coordinates to annotate() to position the annotation where we want.\n\nyear_total_line &lt;- yearly_rates_joined %&gt;% \n  group_by(Year) %&gt;% \n  summarize(TotalCount = sum(TotalCount)) %&gt;% \n  ggplot(aes(x=Year, y=TotalCount)) + \n  geom_line() +\n  geom_point() + \n  scale_x_continuous(breaks = seq(from=1900, to=2000, by=10)) +\n  geom_vline(xintercept = 1963, color = \"red\", linetype= \"dashed\") +\n  annotate(geom = \"label\", x=1963, y=800000, label=\"1963: vaccine introduced\")\n\nyear_total_line\n\n\n\n\n\n\n\n\nFinally, let’s add a title and axis labels to our plot with the labs() function. Note that axis labels will automatically be supplied from the column names, but you can use this function to override those defaults.\n\nyear_total_line &lt;- \n  yearly_rates_joined %&gt;% \n  group_by(Year) %&gt;% \n  summarize(TotalCount = sum(TotalCount)) %&gt;% \n  ggplot(aes(x=Year, y=TotalCount)) + \n  geom_line() +\n  geom_point() + \n  scale_x_continuous(breaks = seq(from=1900, to=2000, by=10)) +\n  geom_vline(xintercept = 1963, color = \"red\", linetype= \"dashed\") +\n  annotate(geom = \"label\", x=1963, y=800000, label=\"1963: vaccine introduced\") +\n  labs(title = \"Measles Cases Decrease After Vaccine Introduced\", x = \"Year\", y = \"Total Measles Case Count\")\n\nyear_total_line\n\n\n\n\n\n\n\n\nNow, we have a pretty nice looking graph. Finally, let’s save our plot to a png file, so we can share it or put it in reports. To do this we use the function called ggsave().\n\nggsave(\"figures/yearly_measles_count.png\", plot = year_total_line)\n\n\nyearly_rates_joined %&gt;% \n  group_by(Year, region) %&gt;% \n  summarize(TotalCount = sum(TotalCount)) %&gt;% \n  ggplot(aes(x=Year, y=TotalCount, group=region, color=region)) + \n  geom_line() +\n  scale_x_continuous(breaks = seq(from=1900, to=2000, by=10)) +\n  geom_vline(xintercept = 1963, color = \"red\", linetype= \"dashed\") +\n  annotate(geom = \"label\", x=1963, y=800000, label=\"1963: vaccine introduced\") +\n  labs(title = \"Measles Cases Decrease After Vaccine Introduced\", x = \"Year\", y = \"Total Measles Case Count\")\n\n\n\n\n\n\n\n\n\n\nMaking Grouped Graphs\n\n\n\n\n\n\nWorking with color palettes\n\n\n\nWhile ggplot comes with a default color palette, there are numerous other palettes out there you can use, such as:\n\nRColorBrewer\nviridis\nggthemes\nggsci\nwesanderson\n\n\n\nLet’s try applying a viridis palette. viridis was designed to be especially robust for many forms of color-blindness. It is also meant to print well in grey scale. As an additional advantage, a lightweight form of the package is included with ggplot2, so there is no need to install additional packages.\nTo do this, we need to change our function scale_fill_discrete() to scale_viridis_d()\n\nyearly_rates_joined %&gt;% \n  group_by(Year, region) %&gt;% \n  summarize(TotalCount = sum(TotalCount)) %&gt;% \n  ggplot(aes(x=Year, y=TotalCount, group=region, color=region)) + \n  geom_line(linewidth=1) +\n  scale_x_continuous(breaks = seq(from=1900, to=2000, by=10)) +\n  geom_vline(xintercept = 1963, color = \"red\", linetype= \"dashed\") +\n  annotate(geom = \"label\", x=1963, y=400000, label=\"1963: vaccine introduced\") +\n  labs(title = \"Measles Cases Decrease After Vaccine Introduced\", x = \"Year\", y = \"Total Measles Case Count\") +\n  scale_color_viridis_d()\n\n\n\n\n\n\n\n\nLearn more from the viridis documentation\n\n\nChanging the theme\nThe theme of a ggplot2 graph controls the overall look and all non-data elements of the plot. There are several built-in themes which can be applied as another layer. Start typing theme_ in RStudio to see a list of themes. You can also use the theme() function to modify aspects of an existing theme. Here we apply theme_classic() which removes the grid lines and grey background of the default theme.\n\nyearly_rates_joined %&gt;% \n  group_by(Year, region) %&gt;% \n  summarize(avg_rate = mean(epi_rate)) %&gt;% \n  ggplot(aes(x=Year, y=avg_rate, group=region, color=region)) + \n  geom_line(linewidth=1) +\n  scale_x_continuous(breaks = seq(from=1900, to=2000, by=10)) +\n  geom_vline(xintercept = 1963, color = \"red\", linetype= \"dashed\") +\n  annotate(geom = \"label\", x=1963, y=8000, label=\"1963: vaccine introduced\") +\n  labs(title = \"Measles Cases Decrease After Vaccine Introduced\", x = \"Year\", y = \"Total Measles Case Count\") +\n  scale_color_viridis_d() +\n  theme_classic()"
  },
  {
    "objectID": "02-DataVisualization.html#faceting-and-small-multiples",
    "href": "02-DataVisualization.html#faceting-and-small-multiples",
    "title": "Data Visualization with ggplot2",
    "section": "Faceting and Small Multiples",
    "text": "Faceting and Small Multiples\nIt can be difficult to understand a graph with too much data. Even just five lines\n\nyearly_rates_joined %&gt;% \n  group_by(Year, region) %&gt;% \n  summarize(avg_rate = mean(epi_rate)) %&gt;% \n  ggplot(aes(x=Year, y=avg_rate, group=region, color=region)) + \n  geom_line(linewidth=1) +\n  scale_x_continuous(breaks = seq(from=1900, to=2000, by=10)) +\n  geom_vline(xintercept = 1963, color = \"red\", linetype= \"dashed\") +\n  annotate(geom = \"label\", x=1963, y=8000, label=\"1963: vaccine introduced\") +\n  labs(title = \"Measles Cases Decrease After Vaccine Introduced\", x = \"Year\", y = \"Total Measles Case Count\") +\n  scale_color_viridis_d() +\n  facet_wrap(~region, nrow=2) +\n  theme_classic()\n\n\n\n\n\n\n\n\n\ntmp &lt;- yearly_rates_joined %&gt;% \ngroup_by(Year, region) %&gt;% \nsummarize(avg_rate = mean(epi_rate)) %&gt;% \nmutate(region2=region) %&gt;% \nselect(-region)\n\nWe could also use highlighting to do away with noise in a line graph. First create a new data frame.\n\nregional_rates &lt;- yearly_rates_joined %&gt;% filter(division==\"South Atlantic\" & between(Year, 1950, 1980))\n\nThen we can create two geom_line layers and highlight just the one in the facet.\n\ntmp &lt;- regional_rates %&gt;%\n  mutate(State2=State)\n\ntmp %&gt;%\n  ggplot(aes(x=Year, y=epi_rate)) +\n  geom_line(data=tmp %&gt;% dplyr::select(-State), aes(group=State2), color=\"grey\", linewidth=0.5, alpha=0.5) +\n  geom_line(aes(color=state), color=\"#69b3a2\", linewidth=1.2 ) +\n  scale_x_continuous(breaks=seq(from=1950, to=1980, by=5)) +\n theme_minimal() +\n  theme(\n    legend.position=\"none\",\n    plot.title = element_text(size=14),\n    panel.grid = element_blank()\n  ) +\n  ggtitle(\"A comparison of measles cases in the South Atlantic Region\") +\n  facet_wrap(~State, ncol = 2)"
  },
  {
    "objectID": "02-DataVisualization.html#maps",
    "href": "02-DataVisualization.html#maps",
    "title": "Data Visualization with ggplot2",
    "section": "Maps",
    "text": "Maps\nWhile we were successful at creating a bar chart to compare measles rates in each state, it is often more helpful to use a map to visualize geographic data. There are multiple types of map-based visualizations in R and tools for creating them. While it is possible to make interactive and animated maps in R, in this lesson, we will only cover static maps.\nIn this lesson, we will focus on creating choropleths. Despite the funny name, this is a visualization you have likely seen many many times. A choropleth is a map that links geographic areas or boundaries to some numeric variable.\nggplot2 needs a little help to make map visualizations. Depending on the geographies you want to map, you may need to find geoJSON or shapefiles. There are also several packages in R that come pre-loaded with background maps of common geographies. We’ll be using one in this lesson called usmap. There are several advantages to this package:\n\nIt contains maps of the US with both state and county boundaries.\nYou can create maps based on census regions and divisions. 3. Alaska and Hawaii are included, while many map packages only have a map of the continental US.\nIt creates the map as a ggplot2 object, so you can customize the visualization with ggplot2 functions (i.e. the things you’ve been learning in this lesson!)\n\nWe’ve installed usmap in your RStudio Cloud project, so now let’s load it into our session.\n\nlibrary(usmap)\n\nThe main function in this package is plot_usmap. When you call it without any arguments, you get the background map of the US.\n\nplot_usmap()\n\n\n\n\n\n\n\n\nBy default it shows state boundaries, but we could also ask it to show county boundaries\n\nplot_usmap(regions=\"counties\")\n\n\n\n\n\n\n\n\nSince we do not have that level of data in our dataset, we’ll use the default option. There are two required arguments to plot_usmap().\n\nThe first is a data frame specified with the data argument. This data frame must have a column called state or fips which contains state names or FIPS (Federal Information Processing) codes. FIPS codes must be used for county level data. This data frame must also have a column of values for each state or FIPS.\nThe second argument is the name of the column that contains the values, specified by the value argument.\n\nLet’s first create a data frame with just our 1963 data.\n\nmeasles1963df &lt;- yearly_rates_joined %&gt;% \n  filter(Year==1963) %&gt;% \nrename(state=State)\n\nNow let’s plot our data with plot_usmap(). Remember it’s important to use rate here rather than our raw count numbers since we are dealing with areas of vastly different populations.\n\nplot_usmap(data=measles1963df, values = \"epi_rate\")\n\n\n\n\n\n\n\n\nWe are provided with a default color scheme, but we can adjust this. Before we do though, it’s worth talking a little about some considerations for using color in visualizations. Color can make a huge difference to the effectiveness of your visualization, and it’s important to think carefully about your choices. For example, in our default color palette, many of the shades are pretty dark, and it is hard to visually distinguish among them. When choosing a palette, you want to be sure shades can be easily distinguished from one another. Also, choose palettes that are color-blind friendly and would hold up well if you visualization was printed in greyscale.\n\nlibrary(viridis)\n\nviridis is integrated with ggplot2, and our map is a ggplot object, we can call the function scale_fill_viridis and add it to our plot.\n\nplot_usmap(data=measles1963df, values = \"epi_rate\") +\n  scale_fill_viridis()\n\n\n\n\n\n\n\n\nNote how the brighter areas seem to highlight the areas of greater concern.\nIf you prefer the darker colors to represent higher rates, and lighter to represent lower, we can switch the direction of the palette with the direction argument.\n\nplot_usmap(data=measles1963df, values = \"epi_rate\") +\n  scale_fill_viridis(direction = -1)\n\n\n\n\n\n\n\n\nLet’s try another of the viridis palettes.\n\nplot_usmap(data=measles1963df, values = \"epi_rate\") +\n  scale_fill_viridis(option = \"rocket\", direction = -1) \n\n\n\n\n\n\n\n\nLet’s add a title, assign to an object, and save to a png file.\n\nmap_1963 &lt;- plot_usmap(data=measles1963df, values = \"epi_rate\") +\n  scale_fill_viridis(option = \"rocket\", direction = -1) + \n  labs(title = \"Incidence Rate of Measles per 1000 people in 1963\")\n\nggsave(filename = \"figures/map_1963.png\", plot = map_1963, bg = \"white\")"
  },
  {
    "objectID": "02-DataVisualization.html#next-steps-from-beginnr-to-practitionr",
    "href": "02-DataVisualization.html#next-steps-from-beginnr-to-practitionr",
    "title": "Data Visualization with ggplot2",
    "section": "Next Steps: From BeginnR to PractitionR",
    "text": "Next Steps: From BeginnR to PractitionR\nI hope you enjoyed this very brief introduction to R. You may be wondering - where do you go from here?\nThere are tons of R classes and tutorials on the internet, but the best way to learn R is to use it! I recommend picking a data set and just playing around. There’s no harm in making mistakes along the way. It’s much easier to find a useful tutorial if you look for ones that teach a specific task you want to accomplish.\nAlso, check out these helpful resources:\n\nR for Data Science, by Hadley Wickham\nTidyverse documentation\nR Graph Gallery\nR Graphics Cookbook"
  },
  {
    "objectID": "02-DataVisualization.html#footnotes",
    "href": "02-DataVisualization.html#footnotes",
    "title": "Data Visualization with ggplot2",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nSlides created by the Visualizing the Future project, made possible in part by the Institute of Museum and Library Services, RE-73-18-0059-18.↩︎"
  }
]