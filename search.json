[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Class Title Here",
    "section": "",
    "text": "Schedule\n\n\n\nDate\nTopic\n\n\n\n\nTBD\nTBD\n\n\nTBD\nTBD"
  },
  {
    "objectID": "index.html#course-description",
    "href": "index.html#course-description",
    "title": "Class Title Here",
    "section": "",
    "text": "Schedule\n\n\n\nDate\nTopic\n\n\n\n\nTBD\nTBD\n\n\nTBD\nTBD"
  },
  {
    "objectID": "index.html#acknowledgements",
    "href": "index.html#acknowledgements",
    "title": "Class Title Here",
    "section": "Acknowledgements",
    "text": "Acknowledgements"
  },
  {
    "objectID": "index.html#license",
    "href": "index.html#license",
    "title": "Class Title Here",
    "section": "License",
    "text": "License\nThis material is shared under a CC-BY 4.0 license."
  },
  {
    "objectID": "01-DataWrangling.html",
    "href": "01-DataWrangling.html",
    "title": "Data Wrangling with R",
    "section": "",
    "text": "By the end of this session, students will be able to:\n\nExplain some benefits of learning R\nNavigate RStudio\nIdentify sources of documentation about R packages and functions\nApply commonly used tidyverse functions to a real data set"
  },
  {
    "objectID": "01-DataWrangling.html#learning-objectives",
    "href": "01-DataWrangling.html#learning-objectives",
    "title": "Data Wrangling with R",
    "section": "",
    "text": "By the end of this session, students will be able to:\n\nExplain some benefits of learning R\nNavigate RStudio\nIdentify sources of documentation about R packages and functions\nApply commonly used tidyverse functions to a real data set"
  },
  {
    "objectID": "01-DataWrangling.html#why-learn-r",
    "href": "01-DataWrangling.html#why-learn-r",
    "title": "Data Wrangling with R",
    "section": "Why learn R?",
    "text": "Why learn R?\n\nR is free, open-source, and cross-platform. Anyone can inspect the source code to see how R works. Because of this transparency, there is less chance for mistakes, and if you (or someone else) find some, you can report and fix bugs. Because R is open source and is supported by a large community of developers and users, there is a very large selection of third-party add-on packages which are freely available to extend R’s native capabilities.\nR code is great for reproducibility. Reproducibility is when someone else (including your future self) can obtain the same results from the same dataset when using the same analysis. R integrates with other tools to generate manuscripts from your code. If you collect more data, or fix a mistake in your dataset, the figures and the statistical tests in your manuscript are updated automatically.\nR relies on a series of written commands, not on remembering a succession of pointing and clicking. If you want to redo your analysis because you collected more data, you don’t have to remember which button you clicked in which order to obtain your results; you just have to run your script again.\nR is interdisciplinary and extensible With 10,000+ packages that can be installed to extend its capabilities, R provides a framework that allows you to combine statistical approaches from many scientific disciplines to best suit the analytical framework you need to analyze your data. For instance, R has packages for image analysis, GIS, time series, population genetics, and a lot more.\nR works on data of all shapes and sizes. The skills you learn with R scale easily with the size of your dataset. Whether your dataset has hundreds or millions of lines, it won’t make much difference to you. R is designed for data analysis. It comes with special data structures and data types that make handling of missing data and statistical factors convenient. R can connect to spreadsheets, databases, and many other data formats, on your computer or on the web.\nR produces high-quality graphics. The plotting functionalities in R are endless, and allow you to adjust any aspect of your graph to convey most effectively the message from your data.\nR has a large and welcoming community. Thousands of people use R daily. Many of them are willing to help you through mailing lists and websites such as Stack Overflow, or on the RStudio community. Questions which are backed up with short, reproducible code snippets are more likely to attract knowledgeable responses."
  },
  {
    "objectID": "01-DataWrangling.html#the-data",
    "href": "01-DataWrangling.html#the-data",
    "title": "Data Wrangling with R",
    "section": "The Data",
    "text": "The Data\nFor this lesson we will be using data which comes from Project Tycho - an open data project from the University of Pittsburgh which provides standardized datasets on numerous diseases to aid global health research.\nThroughout this lesson, we will be using a dataset from Project Tycho featuring historical counts of measles cases in the U.S.. We want to clean and present this data in a way that makes it easy to see how measles cases fluctuated over time.\nA useful feature of Project Tycho data is their use of a common set of variables. Read more about their data format."
  },
  {
    "objectID": "01-DataWrangling.html#starting-out-in-r",
    "href": "01-DataWrangling.html#starting-out-in-r",
    "title": "Data Wrangling with R",
    "section": "Starting out in R",
    "text": "Starting out in R\nR is both a programming language and an interactive environment for data exploration and statistics.\nWorking with R is primarily text-based. The basic mode of use for R is that the user provides commands in the R language and then R computes and displays the result.\n\nDownloading, Installing and Running R\nDownload\nR can be downloaded from CRAN (The Comprehensive R Archive Network) for Windows, Linux, or Mac.\nInstall\nInstallation of R is like most software packages and you will be guided. Should you have any issues or need help you can refer to R Installation and Administration\nRunning\nR can be launched from your software or applications launcher or When working at a command line on UNIX or Windows, the command R can be used for starting the main R program in the form R\nYou will see a console similar to this appear:\n\n\n\n\n\n\n\n\n\nWhile it is possible to work solely through the console or using a command line interface, the ideal environment to work in R is RStudio.\n\n\nRStudio\nRStudio is a user interface for working with R. It is called an Integrated Development Environment (IDE): a piece of software that provides tools to make programming easier. RStudio acts as a sort of wrapper around the R language. You can use R without RStudio, but it’s much more limiting. RStudio makes it easier to import datasets, create and write scripts, and makes using R much more effective. RStudio is also free and open source. To function correctly, RStudio needs R and therefore both need to be installed on your computer. But for this class we’ll be using a browser based version called RStudio Cloud (see directions in the [RStudio Cloud] section below.)\nRStudio is divided into four “panes”. The placement of these panes and their content can be customized (see menu, Tools -&gt; Global Options -&gt; Pane Layout).\nThe Default Layout is:\n\nTop Left - Source: your scripts and documents\nBottom Left - Console: what R would look and be like without RStudio\nTop Right - Environment/History: look here to see what you have done\nBottom Right - Files and more: see the contents of the project/working directory here, like your Script.R file\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPosit Cloud\n\n\n\n\n\nPosit (RStudio) Cloud is a browser-based version of RStudio. It will allow you to use RStudio without needing to download anything to your computer. You can also easily share your R projects with others. While you will want to download R and RStudio for regular use, we will be using RStudio Cloud for this session so we can all work from the same environment.\nGet Started:\n\nCreate your free RStudio Cloud account at https://rstudio.cloud/plans/free.\nGo to the class project \nNote the text that marks this as a Temporary Copy. Select the Save a Permanent Copy button to begin working!"
  },
  {
    "objectID": "01-DataWrangling.html#r-scripts",
    "href": "01-DataWrangling.html#r-scripts",
    "title": "Data Wrangling with R",
    "section": "R Scripts",
    "text": "R Scripts\nA script is a document in which you write your code. This makes it easy to re-run that code when you need to. In addition to code, your script can also have comments, which start with a # symbol. These comments make your script more human readable, but are ignored by the computer.\nTo get started in this lesson - open up the script in your RStudio Project called rwd_lesson.R"
  },
  {
    "objectID": "01-DataWrangling.html#welcome-to-the-tidyverse",
    "href": "01-DataWrangling.html#welcome-to-the-tidyverse",
    "title": "Data Wrangling with R",
    "section": "Welcome to the Tidyverse",
    "text": "Welcome to the Tidyverse\nIn this lesson, we will be using a group of packages which are part of what is known as the tidyverse - “an opinionated collection of R packages designed for data science. All packages share an underlying design philosophy, grammar, and data structures.”1, developed by Hadley Wickham.\n\n\n\n\n\n\nWhat is a package?\n\n\n\nAs mentioned above, R is extensible and packages are the way to extend the base functionality of R. Each package is a collection of functions, code, data, and documentation. Packages are specialized to accomplish a particular set of tasks. Users can easily install packages from package repositories, such as the central repository CRAN (Comprehensive R Archive Network) and Bioconductor, an important source of bioinformatics packages.\nThe sheer number of R packages can seem overwhelming to a beginner and a common question we hear is, “But how do I know what package to use?”. One place is to start is to take a look at CRAN Task Views, which organizes packages by topic. You can also try an internet search like “How do I do X in R” and this will typically lead you to solutions that mention packages you need to accomplish the task.\nOne reason we are focusing on the tidyverse packages in this class is because they are so versatile and might be the only packages you need for much of what you want to do in R.\n\n\nThe tidyverse packages we will be using include:\n\nreadr for importing data into R\ndplyr for handling common data wrangling tasks for tabular data\ntidyr which enables you to swiftly convert between different data formats (long vs. wide) for plotting and analysis\nlubridate for working with dates\nggplot2 for visualizing data (we’ll explore this package in the next session).\n\nFor the full list of tidyverse packages and documentation visit tidyverse.org You can install these packages individually, or you can install the entire tidyverse in one go."
  },
  {
    "objectID": "01-DataWrangling.html#installing-and-loading-packages",
    "href": "01-DataWrangling.html#installing-and-loading-packages",
    "title": "Data Wrangling with R",
    "section": "Installing and loading packages",
    "text": "Installing and loading packages\nWhen you first install R on your computer, it comes with a set of built-in packages and functions collectively referred to as Base R. To add additional packages, you must first install that package, and then load it into your current session. If you are using the class Posit Cloud project(UPDATE LINK), the tidyverse has already been installed, so we just need to load it. You only need to install a package once on a system, but you will load it each time you start a new r session. If the package had not already been installed, we would install with a function called install.packages().\n\n#install tidyverse if you haven't yet\n#install.packages(\"tidyverse\")\n\n#load tidyverse\nlibrary(tidyverse)"
  },
  {
    "objectID": "01-DataWrangling.html#functions",
    "href": "01-DataWrangling.html#functions",
    "title": "Data Wrangling with R",
    "section": "Functions",
    "text": "Functions\ninstall.packages() and library() are two examples of functions. Functions are one of the most important components of R code. A function is like a canned script. It usually takes some inputs, called arguments inside parentheses following the name of the function, performs one or more tasks, and often returns some kind of output. The library() function takes the name of the package to load as it’s argument.\nHow do you know what arguments a function takes? For that you need to turn to the documentation of a particular package, or from within RStudio you can look up a function with ?function-name. Let’s try it with the library() function.\n\n?library\n\nThis opens the help pane in the lower right corner of RStudio. The documentation provides you with all the arguments and any default values, along with explanations of the arguments. Here we see that the the library function has the argument package with no defaults."
  },
  {
    "objectID": "01-DataWrangling.html#what-is-tidy-data",
    "href": "01-DataWrangling.html#what-is-tidy-data",
    "title": "Data Wrangling with R",
    "section": "What is Tidy Data?",
    "text": "What is Tidy Data?\nThe tidyverse is so named from the concept of “tidy data”. Data is considered “tidy” if it follows three rules:\n\nEach column is a variable\nEach row is an observation\nEach cell is a single value2\n\nData “in the wild” often isn’t tidy, but the tidyverse packages can help you create and analyze tidy datasets.\n\n\n\n\n\ntidy data structure3"
  },
  {
    "objectID": "01-DataWrangling.html#importing-data",
    "href": "01-DataWrangling.html#importing-data",
    "title": "Data Wrangling with R",
    "section": "Importing data",
    "text": "Importing data\nNow,that the tidyverse is loaded, we can use it to import some data into our RStudio session. We are using a function from the readr package called read_csv(). This function takes as an argument the path to where the file is located. Let’s start by reading in measles_us file in the /data folder.\n\nread_csv(\"data/measles_us.csv\")\n\nRows: 422051 Columns: 15\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (11): ConditionName, PathogenName, CountryName, CountryISO, Admin1Name, ...\ndbl  (3): ConditionSNOMED, PartOfCumulativeCountSeries, CountValue\nlgl  (1): DiagnosisCertainty\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\n\n# A tibble: 422,051 × 15\n   ConditionName ConditionSNOMED PathogenName  CountryName CountryISO Admin1Name\n   &lt;chr&gt;                   &lt;dbl&gt; &lt;chr&gt;         &lt;chr&gt;       &lt;chr&gt;      &lt;chr&gt;     \n 1 Measles              14189004 Measles virus UNITED STA… US         WISCONSIN \n 2 Measles              14189004 Measles virus UNITED STA… US         WISCONSIN \n 3 Measles              14189004 Measles virus UNITED STA… US         WISCONSIN \n 4 Measles              14189004 Measles virus UNITED STA… US         WISCONSIN \n 5 Measles              14189004 Measles virus UNITED STA… US         WISCONSIN \n 6 Measles              14189004 Measles virus UNITED STA… US         WISCONSIN \n 7 Measles              14189004 Measles virus UNITED STA… US         WISCONSIN \n 8 Measles              14189004 Measles virus UNITED STA… US         WISCONSIN \n 9 Measles              14189004 Measles virus UNITED STA… US         WISCONSIN \n10 Measles              14189004 Measles virus UNITED STA… US         WISCONSIN \n# ℹ 422,041 more rows\n# ℹ 9 more variables: Admin1ISO &lt;chr&gt;, Admin2Name &lt;chr&gt;, CityName &lt;chr&gt;,\n#   PeriodStartDate &lt;chr&gt;, PeriodEndDate &lt;chr&gt;,\n#   PartOfCumulativeCountSeries &lt;dbl&gt;, DiagnosisCertainty &lt;lgl&gt;,\n#   SourceName &lt;chr&gt;, CountValue &lt;dbl&gt;\n\n\nBut doing this just gives us a preview of the data in the console. To really use the data, we need to assign it to an object. An object is like a container for a numerical value, string, data set, image, and much more. Just about everything in R is an object. You might liken them to variables in other programming languages or in math. We create an object, by giving our data a name and use the assignment operator, which looks like an arrow &lt;-. You can manually type in the lesser than sign &lt; and hyphen -, or use the keyboard shortcut Alt + -.\nLet’s call our new object measles_us. Object names should be short and easy to understand. They can’t have spaces, so you’ll want to separate multiple words with a underscore, or by using camel case. Object names also need to start with a letter not a number, and it’s best to avoid using names of common functions.\n\nmeasles_us &lt;- read_csv(\"data/measles_us.csv\")\n\nWhen you create an object, it shows up in your environment pane (the upper right panel). If we check our environment pane, we should now see an object called measles_us.\nLet’s do the same for the states.csv file.\n\nstates &lt;- read_csv(file = \"data/states.csv\")\n\nRows: 50 Columns: 3\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (3): name, division, region\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message."
  },
  {
    "objectID": "01-DataWrangling.html#exploring-and-summarizing-data",
    "href": "01-DataWrangling.html#exploring-and-summarizing-data",
    "title": "Data Wrangling with R",
    "section": "Exploring and Summarizing data",
    "text": "Exploring and Summarizing data\nAfter reading the data, you will typically want to start exploring it.\n\nVectors and Data Frames and Tibbles oh my!\nFirst, it’s important to understand the type of object we just created. In R, tabular data like you find in a spreadsheet is stored in a data frame, one of the fundamental data structures in R. A data frame is rectangular, two dimensional data. That is, it has both columns and rows. Data frames can store multiple data types, such as numeric, character, and logical data.\nA tibble is a tidyverse version of the standard R data frame. For our purposes, the differences are minor enough that we can generally use the terms interchangeably, but to be precise, we will be working with tibbles in this lesson. All tibbles are data frames, but not all data frames are tibbles.\nAnother important R data structure is a vector. A vector is a one-dimensional structure. That is, it is simply a sequence of elements. A vector can have only one data type. Data frames are created from multiple vectors, that is, each column in a data frame is a vector.\n\n\nBase R functions for exploring data\nView() opens the data as a file in your documents pane.This is a good way to see the data in a familiar spreadsheet-like format.\n\nView(measles_us)\n\nUse summary() to look at each column and find the data type and interquartile range for numeric data.\n\nsummary(measles_us)\n\nSometimes we get data with a large number of missing values. It can be helpful to know where data is missing before attempting to do any further analysis. R uses NA to indicate missing values. We can use the function is.na() to test for the presence of NAs in our data.is.na() will return a vector of values TRUE or FALSE. TRUE if the value is NA, FALSE if it is not. When we examined our data with the View function, we might have noticed that the first several values in Admin2Name column are missing (NA). We might want to know how many missing values total are in that column.\n\nis.na(measles_us$Admin2Name)\n\nAfter running this code you should see TRUE printed out repeatedly in the console. R is running through that column and printing TRUE whenever it runs into a missing value. But this still does not help us get the total number of NAs. To do that we need to nest the above code in another function sum().\n\nsum(is.na(measles_us$Admin2Name))\n\n[1] 198104\n\n\nsum() treats each each TRUE as a 1 and each FALSE as a 0. In that column there are 198104 out of 422051\nBut, if you a lot of variables (columns), it would be a pain to do this for each one. So instead we can use a similar function colSums\n\ncolSums(is.na(measles_us))\n\n              ConditionName             ConditionSNOMED \n                          0                           0 \n               PathogenName                 CountryName \n                          0                           0 \n                 CountryISO                  Admin1Name \n                          0                           0 \n                  Admin1ISO                  Admin2Name \n                          0                      198104 \n                   CityName             PeriodStartDate \n                     198104                           0 \n              PeriodEndDate PartOfCumulativeCountSeries \n                          0                           0 \n         DiagnosisCertainty                  SourceName \n                     422051                           0 \n                 CountValue \n                          0 \n\n\n\n\ntidyverse functions for exploring data\nThe glimpse() function which is part of the tidyverse package tibble, lets you see the column names and data types clearly.\n\nglimpse(measles_us)\n\ndistinct() returns the distinct rows in a data frame. It can be used on a column to return the distinct values in that column. The first argument you supply is the data frame object. Subsequent arguments include the variables you want to count.\n\ndistinct(measles_us, ConditionName)\n\n# A tibble: 1 × 1\n  ConditionName\n  &lt;chr&gt;        \n1 Measles      \n\n\n\ndistinct(measles_us, Admin1Name)\n\n# A tibble: 56 × 1\n   Admin1Name\n   &lt;chr&gt;     \n 1 WISCONSIN \n 2 OHIO      \n 3 MICHIGAN  \n 4 NEVADA    \n 5 NEW JERSEY\n 6 WASHINGTON\n 7 DELAWARE  \n 8 KENTUCKY  \n 9 WYOMING   \n10 INDIANA   \n# ℹ 46 more rows\n\n\ncount() is similar to distinct() but also returns the number of observations (i.e. rows) for each of those distinct values. The first argument you supply is the data frame object. Subsequent arguments include the variables you want to count.\n\n count(measles_us, Admin1Name) \n\n# A tibble: 56 × 2\n   Admin1Name               n\n   &lt;chr&gt;                &lt;int&gt;\n 1 ALABAMA               7458\n 2 ALASKA                1869\n 3 AMERICAN SAMOA         118\n 4 ARIZONA               4685\n 5 ARKANSAS              5643\n 6 CALIFORNIA           14354\n 7 COLORADO              8042\n 8 CONNECTICUT          10816\n 9 DELAWARE              4507\n10 DISTRICT OF COLUMBIA  5027\n# ℹ 46 more rows\n\n\n\n\n\n\n\n\nMake code flow with the pipe %&gt;%\n\n\n\nBefore we go any further - I want to introduce you to an important time-saving symbol in R called the pipe %&gt;% (CTRL + SHIFT + M). The pipe allows you to take the output of the left-hand expression and make it the input of the right-hand expression. It allows you to chain together multiple functions and avoid nesting. With the pipe, we can rewrite the above code as follows:\n\nmeasles_us %&gt;% \n  count(Admin1Name)\n\n# A tibble: 56 × 2\n   Admin1Name               n\n   &lt;chr&gt;                &lt;int&gt;\n 1 ALABAMA               7458\n 2 ALASKA                1869\n 3 AMERICAN SAMOA         118\n 4 ARIZONA               4685\n 5 ARKANSAS              5643\n 6 CALIFORNIA           14354\n 7 COLORADO              8042\n 8 CONNECTICUT          10816\n 9 DELAWARE              4507\n10 DISTRICT OF COLUMBIA  5027\n# ℹ 46 more rows\n\n\nIn many tidyverse functions, the first argument is the name of the data frame you’re applying the function to. So when you use the pipe, you’ll generally start a line of code with the name of a data frame. One benefit you might notice right away, is that when we use the pipe, RStudio will supply the column names which helps to reduce typing and typos.\n\n\n\n\n\n\n\n\nCHALLENGE\n\n\n\nNow let’s try exploring the states tibble in our environment\n\nUse glimpse() to inspect the columns and data types in the dataset.\nUse distinct() to find out the distinct values in the region column.\nUsing count(), find out how many states are in each region.\nUsing count(), find out how many states are in each region AND division. HINT: You can add additional column names to distinct() and count() to look at combinations of columns."
  },
  {
    "objectID": "01-DataWrangling.html#subsetting-data-with-select-and-filter",
    "href": "01-DataWrangling.html#subsetting-data-with-select-and-filter",
    "title": "Data Wrangling with R",
    "section": "Subsetting data with select() and filter()",
    "text": "Subsetting data with select() and filter()\nReal data sets can be quite large. So, once you’ve explored your data, you may want to start trimming it down to just the variables and conditions you’re interested in. In this section, we’ll look at two functions from the tidyverse package called dplyr: select() which lets you choose columns (variables) and filter() which lets you choose rows. (Note: dplyr is known for using easy to understand verbs for its function names.)\n\nselect()\nselect() lets you choose columns by name. The syntax of this function is similar to the the ones we’ve already learned count() and distinct(). We need to supply the function with the name of the tibble and the columns. This will create a new tibble with just those columns.\nAs with all tidyverse functions, we can use %&gt;% to make this easier.\n\nmeasles_us %&gt;% \nselect(Admin1Name, CountValue)\n\n# A tibble: 422,051 × 2\n   Admin1Name CountValue\n   &lt;chr&gt;           &lt;dbl&gt;\n 1 WISCONSIN          85\n 2 WISCONSIN         120\n 3 WISCONSIN          84\n 4 WISCONSIN         106\n 5 WISCONSIN          39\n 6 WISCONSIN          45\n 7 WISCONSIN          28\n 8 WISCONSIN         140\n 9 WISCONSIN          48\n10 WISCONSIN          85\n# ℹ 422,041 more rows\n\n\nIf you want to select several columns that are next to each other, you can use : to specify a range, rather than writing each name out separately.\n\nmeasles_us %&gt;% \nselect( ConditionName:Admin1ISO)\n\n# A tibble: 422,051 × 7\n   ConditionName ConditionSNOMED PathogenName  CountryName CountryISO Admin1Name\n   &lt;chr&gt;                   &lt;dbl&gt; &lt;chr&gt;         &lt;chr&gt;       &lt;chr&gt;      &lt;chr&gt;     \n 1 Measles              14189004 Measles virus UNITED STA… US         WISCONSIN \n 2 Measles              14189004 Measles virus UNITED STA… US         WISCONSIN \n 3 Measles              14189004 Measles virus UNITED STA… US         WISCONSIN \n 4 Measles              14189004 Measles virus UNITED STA… US         WISCONSIN \n 5 Measles              14189004 Measles virus UNITED STA… US         WISCONSIN \n 6 Measles              14189004 Measles virus UNITED STA… US         WISCONSIN \n 7 Measles              14189004 Measles virus UNITED STA… US         WISCONSIN \n 8 Measles              14189004 Measles virus UNITED STA… US         WISCONSIN \n 9 Measles              14189004 Measles virus UNITED STA… US         WISCONSIN \n10 Measles              14189004 Measles virus UNITED STA… US         WISCONSIN \n# ℹ 422,041 more rows\n# ℹ 1 more variable: Admin1ISO &lt;chr&gt;\n\n\nNow, let’s think through which columns we want for our analysis and save this to a new object called measles_select. It’s always a good idea to create new objects when you make major changes to your data.\nFor this exercise, we want to look at trends in number of measles cases over time. To do that, we’ll need to keep our CountValue variable, as and the date variables (PeriodStartDate and PeriodEndDate), as well as the PartOfCumulativeCountSeries variable, which will help us understand how to use the dates (more on this later). The first five columns each have only one value. So it might be redundant to keep those, although if we were combining them with other Project Tycho datasets they could be useful. It might be interesting to get a state-level view of the data, so let’s keep Admin1Name. But we saw that there are a number of missing values in our Admin2Name and CityName variables, so they might not be very useful for our analysis.\n\nmeasles_select &lt;-\n  measles_us %&gt;%\n    select(\n     Admin1Name,\n     PeriodStartDate,\n     PeriodEndDate,\n     PartOfCumulativeCountSeries,\n     CountValue\n)\n\nSometimes when receive a data set or start working with data, you may find that the column names are overly long or not very descriptive or useful, and it may be necessary to rename them. For this, we can use the rename() function. Like naming objects, you should use a simple, descriptive, relatively short name without spaces for your column names. Let’s rename Admin1Name to State to make that more meaningful to us. rename() has the syntax rename(newColumnName = OldColumnName).\n\nmeasles_select &lt;-\n  measles_select %&gt;% \n    rename(State = Admin1Name)\n\nNote that in thise case, we are overwriting our original object with the new name instead of creating a new one!\n\n\nfilter()\nWhile select() acts on columns, filter() acts on rows. filter() takes the name of the data frame and one or more logical conditions as arguments.\n\nmeasles_md &lt;- measles_select %&gt;% \nfilter(State == \"MARYLAND\")\n\nHere we are saying keep all the rows where the value in the State column is “MARYLAND”. Note the use of the double equals sign == versus the singular = sign. The double equal sign is a logical operator. The logical operators are:\n\n\n\noperator\nmeaning\n\n\n\n\n==\nexactly equal\n\n\n!=\nnot equal to\n\n\n&lt;\nless than\n\n\n&lt;=\nless than or equal to\n\n\n&gt;\ngreater than\n\n\n&gt;=\ngreater than or equal to\n\n\nx|y\nx or y\n\n\nx&y\nx and y\n\n\n!x\nnot x\n\n\n\nNote that after running our code, our resulting data frame (our new object measles_md) has 7246 observations (rows) while our original data frame had 422051.\n\n\n\n\n\n\nWarning\n\n\n\nWhen matching strings you must be exact. R is case-sensitive. So State == \"Maryland\" or State == \"maryland\" would return 0 rows.\n\n\nYou can add additional conditions to filter by, separated other logical operators like &, &gt;, and &gt;.\nBelow we want just the rows for Maryland, and only include periods where the count was more than 500 reported cases. Note that while you need quotation marks around character data, you do not need them around numeric data.\n\nmeasles_select %&gt;%\n  filter(State == \"MARYLAND\" & CountValue &gt; 500)\n\n# A tibble: 328 × 5\n   State    PeriodStartDate PeriodEndDate PartOfCumulativeCountSeries CountValue\n   &lt;chr&gt;    &lt;chr&gt;           &lt;chr&gt;                               &lt;dbl&gt;      &lt;dbl&gt;\n 1 MARYLAND 1/29/1928       2/4/1928                                0        504\n 2 MARYLAND 2/5/1928        2/11/1928                               0        563\n 3 MARYLAND 2/12/1928       2/18/1928                               0        696\n 4 MARYLAND 2/19/1928       2/25/1928                               0        750\n 5 MARYLAND 2/26/1928       3/3/1928                                0       1012\n 6 MARYLAND 3/4/1928        3/10/1928                               0        951\n 7 MARYLAND 3/11/1928       3/17/1928                               0       1189\n 8 MARYLAND 3/18/1928       3/24/1928                               0       1163\n 9 MARYLAND 3/25/1928       3/31/1928                               0       1020\n10 MARYLAND 4/1/1928        4/7/1928                                0        753\n# ℹ 318 more rows\n\n\nHere, we joined together 2 conditions with the & logical operator. Then we piped that resulting data frame to count() which remember takes a data frame as its first argument.\nWhat if we wanted to filter our tibble to include just the 50 states and no territories? We sure would not have to write out an expression for each state, or even all the territories.\n\n#we do not want to do this!\n\nmeasles_select %&gt;% \nfilter(State == \"MARYLAND\" & State == \"DELAWARE\" & State == \"Pennsylvania\")\n\n# A tibble: 0 × 5\n# ℹ 5 variables: State &lt;chr&gt;, PeriodStartDate &lt;chr&gt;, PeriodEndDate &lt;chr&gt;,\n#   PartOfCumulativeCountSeries &lt;dbl&gt;, CountValue &lt;dbl&gt;\n\n\nLuckily, We can filter based on a vector of values with the%in% operator (remember we can think of a vector as a column of data). So, we can write some code to filter our data based on list of state names in our states tibble.\n\nmeasles_states_only &lt;-\n  measles_select %&gt;% \n  filter(State %in% states$name)\n\nLet’s save this output to a new object measles_states_only. Notice how we now have fewer rows than we had in our measles_select object.\nWe could alternatively have used negation with the names of the values we specifically wanted to exclude.\n\nmeasles_states_only &lt;- measles_select %&gt;% \n  filter(!State %in% c(\"PUERTO RICO\", \"GUAM\", \"AMERICAN SAMOA\", \"NORTHERN MARIANA ISLANDS\", \"VIRGIN ISLANDS, U.S.\", \"DISTRICT OF COLUMBIA\"))\n\nGreat! Our dataset is really shaping up. Let’s also take a closer look at our date columns. If you look at the first several rows, it looks like each row of our dataset represents about a discrete week of measles case counts. But (as you can read in the Tycho data documentation) there are actually two date series in this dataset - non-cumulative and cumulative. Which series a row belongs to is noted by the PartofCumulativeCountSeries, which as the value 0 if a row is non-cumulative, and 1 if the row is part of a cumulative count.\nTo keep things consistent. Let’s filter our tibble so we only have the non-overlapping discrete weeks.\n\nmeasles_non_cumulative &lt;- \n  measles_states_only %&gt;% \n  filter(PartOfCumulativeCountSeries==0)\n\nOnce again, we have fewer rows than we started with.\n\n\nChallenge\n\nUse filter() to limit the dataset to just the rows containing Maryland, Virginia, or Delaware and more than 1000 cases of measles.\n\nNow let’s do some more with our date variables."
  },
  {
    "objectID": "01-DataWrangling.html#changing-and-creating-variables-with-mutate",
    "href": "01-DataWrangling.html#changing-and-creating-variables-with-mutate",
    "title": "Data Wrangling with R",
    "section": "Changing and creating variables with mutate()",
    "text": "Changing and creating variables with mutate()\nLet’s review the columns in our measles_states_only tibble\n\nglimpse(measles_non_cumulative)\n\nRows: 332,138\nColumns: 5\n$ State                       &lt;chr&gt; \"WISCONSIN\", \"WISCONSIN\", \"WISCONSIN\", \"WI…\n$ PeriodStartDate             &lt;chr&gt; \"11/20/1927\", \"11/27/1927\", \"12/4/1927\", \"…\n$ PeriodEndDate               &lt;chr&gt; \"11/26/1927\", \"12/3/1927\", \"12/10/1927\", \"…\n$ PartOfCumulativeCountSeries &lt;dbl&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, …\n$ CountValue                  &lt;dbl&gt; 85, 120, 84, 106, 39, 45, 28, 140, 48, 85,…\n\n\nWe can see from this that the dates are being interpreted as character data. We want R to recognize them as dates. We can create new variables and adjust existing variables with the mutate() function.\nmutate() takes as an argument the name and definition of the new column you’re creating. You can create multiple new columns at a time, separating each new variable name and definition with a comma. Note that if you use the same variable name as an existing variable name it overwrites that column. Otherwise, it will add a column to your data frame.\nTo change the variable to a date - we are using a date parsing function from another package called lubridate. mdy() takes a character string or number in month-day-year format (as we have here) and returns a formal date object in YYYY-MM-DD format. There are similar functions if the input date is in year-month-day ydm() or day-month-year dmy()\n\nmeasles_non_cumulative &lt;- measles_non_cumulative %&gt;% \nmutate(PeriodStartDate = mdy(PeriodStartDate),\n       PeriodEndDate = mdy(PeriodEndDate))\n\nNote that you can mutate multiple columns at a time, separating each new column definition with a comma.\nNow that R recognizes the date columns as Dates, we can do things like extract parts of the date, such as the year. Let’s create a separate Year column. Later we’ll be able to group our tibble by year for analysis.\n\nmeasles_year &lt;- \n  measles_non_cumulative %&gt;% \n  mutate(Year=year(PeriodStartDate))"
  },
  {
    "objectID": "01-DataWrangling.html#grouping-and-summarizing",
    "href": "01-DataWrangling.html#grouping-and-summarizing",
    "title": "Data Wrangling with R",
    "section": "Grouping and Summarizing",
    "text": "Grouping and Summarizing\nMany data analysis tasks can be approached using the split-apply-combine paradigm: split the data into groups, apply some analysis to each group, and then combine the results. dplyr makes this very easy through the use of the group_by() function.\ngroup_by() is often used together with summarize(), which collapses each group into a single-row summary of that group. group_by() takes as arguments the column names that contain the categorical variables for which you want to calculate the summary statistics.\nHow can we calculate the total number of measles cases for each year?\nFirst we need to group our data by year using our new Year column.\n\nyearly_count_state &lt;-\n  measles_year %&gt;%\n  group_by(Year)\n\nyearly_count_state\n\n# A tibble: 332,138 × 6\n# Groups:   Year [96]\n   State   PeriodStartDate PeriodEndDate PartOfCumulativeCoun…¹ CountValue  Year\n   &lt;chr&gt;   &lt;date&gt;          &lt;date&gt;                         &lt;dbl&gt;      &lt;dbl&gt; &lt;dbl&gt;\n 1 WISCON… 1927-11-20      1927-11-26                         0         85  1927\n 2 WISCON… 1927-11-27      1927-12-03                         0        120  1927\n 3 WISCON… 1927-12-04      1927-12-10                         0         84  1927\n 4 WISCON… 1927-12-18      1927-12-24                         0        106  1927\n 5 WISCON… 1927-12-25      1927-12-31                         0         39  1927\n 6 WISCON… 1928-01-01      1928-01-07                         0         45  1928\n 7 WISCON… 1928-01-08      1928-01-14                         0         28  1928\n 8 WISCON… 1928-01-15      1928-01-21                         0        140  1928\n 9 WISCON… 1928-01-22      1928-01-28                         0         48  1928\n10 WISCON… 1928-01-29      1928-02-04                         0         85  1928\n# ℹ 332,128 more rows\n# ℹ abbreviated name: ¹​PartOfCumulativeCountSeries\n\n\nWhen you inspect your new data frame, everything should look the same. Grouping prepares your data for summarize, but it does not do anything visually to the data.\nNow let’s trying summarizing that data. summarize() condenses the value of the group values to a single value per group. Like mutate(), we provide the function with the name of the new column that will hold the summary information. In this case, we will use the sum() function on the CountValue column and put this in a new column called TotalCount. Summarize will drop the columns that aren’t being used.\n\n#Get totals for each state each year.\nyearly_count &lt;-\n  measles_year %&gt;%\n  group_by(Year) %&gt;%\n  summarise(TotalCount = sum(CountValue))\n\nyearly_count\n\n# A tibble: 96 × 2\n    Year TotalCount\n   &lt;dbl&gt;      &lt;dbl&gt;\n 1  1906       2345\n 2  1907      40199\n 3  1908      54471\n 4  1909      49802\n 5  1910      86984\n 6  1911      59171\n 7  1912      64773\n 8  1913     111431\n 9  1914      56440\n10  1915      93579\n# ℹ 86 more rows\n\n\nA more useful view might be to look for yearly totals of case counts by state. We can group by two variables, Year, and then State.\n\nyearly_count_state &lt;-\n  measles_year %&gt;%\n  group_by(Year, State) %&gt;%\n  summarise(TotalCount = sum(CountValue))\n\n`summarise()` has grouped output by 'Year'. You can override using the\n`.groups` argument.\n\nyearly_count_state\n\n# A tibble: 4,055 × 3\n# Groups:   Year [96]\n    Year State         TotalCount\n   &lt;dbl&gt; &lt;chr&gt;              &lt;dbl&gt;\n 1  1906 CALIFORNIA           224\n 2  1906 CONNECTICUT           23\n 3  1906 FLORIDA                4\n 4  1906 ILLINOIS             187\n 5  1906 INDIANA               20\n 6  1906 KENTUCKY               2\n 7  1906 MAINE                 26\n 8  1906 MASSACHUSETTS        282\n 9  1906 MICHIGAN             320\n10  1906 MISSOURI             274\n# ℹ 4,045 more rows\n\n\nNotice how the use of pipes really comes in handy here. It saved us from having to create and keep track of a number of intermediate objects."
  },
  {
    "objectID": "01-DataWrangling.html#sorting-datasets-with-arrange",
    "href": "01-DataWrangling.html#sorting-datasets-with-arrange",
    "title": "Data Wrangling with R",
    "section": "Sorting datasets with arrange()",
    "text": "Sorting datasets with arrange()\nWhich state in which year had the highest case count? To easily find out, we can use the function arrange(). One of the arguments must be the column you want to sort on.\n\nyearly_count_state %&gt;% arrange(TotalCount)\n\n# A tibble: 4,055 × 3\n# Groups:   Year [96]\n    Year State       TotalCount\n   &lt;dbl&gt; &lt;chr&gt;            &lt;dbl&gt;\n 1  1925 NEVADA               0\n 2  1937 MISSISSIPPI          0\n 3  1938 MISSISSIPPI          0\n 4  1939 MISSISSIPPI          0\n 5  1940 MISSISSIPPI          0\n 6  1940 NEVADA               0\n 7  1941 MISSISSIPPI          0\n 8  1944 MISSISSIPPI          0\n 9  1945 MISSISSIPPI          0\n10  1906 TEXAS                1\n# ℹ 4,045 more rows\n\n\nBy default, arrange sorts in ascending order. To sort by descending order we use together with the desc() function.\n\nyearly_count_state %&gt;% arrange(desc(TotalCount))\n\n# A tibble: 4,055 × 3\n# Groups:   Year [96]\n    Year State        TotalCount\n   &lt;dbl&gt; &lt;chr&gt;             &lt;dbl&gt;\n 1  1938 PENNSYLVANIA     146467\n 2  1941 PENNSYLVANIA     137180\n 3  1938 ILLINOIS         127935\n 4  1942 CALIFORNIA       116180\n 5  1941 OHIO             114788\n 6  1935 MICHIGAN         111413\n 7  1941 NEW YORK         109663\n 8  1938 MICHIGAN         109041\n 9  1934 PENNSYLVANIA     107031\n10  1938 WISCONSIN        104450\n# ℹ 4,045 more rows"
  },
  {
    "objectID": "01-DataWrangling.html#joining-datasets",
    "href": "01-DataWrangling.html#joining-datasets",
    "title": "Data Wrangling with R",
    "section": "Joining Datasets",
    "text": "Joining Datasets\nOf course, looking at total counts in each state is not the most helpful metric without taking population into account. To rectify this, let’s try joining some historical population data with our measles data.\nFirst we need to import the population data4.\n\nhist_pop &lt;-\n  read_csv(\"data/Historical_Population_by_State.csv\")\n\nRows: 107 Columns: 52\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\ndbl (52): DATE, ALASKA, ALABAMA, ARKANSAS, ARIZONA, CALIFORNIA, COLORADO, CO...\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\n\n\nLong vs Wide formats\nRemember that for data to be considered “tidy”, it should be in what is called “long” format. Each column is a variable, each row is an observation, and each cell is a value. Our state population data is in “wide” format, because State Name is being treated as a variable, when it is really a value. Wide data is often preferable for human-readability, but is less ideal for machine-readability. To be able to join this data to our measles dataset, it needs to have 3 columns - Year, State Name, and Population.\nWe will use the package tidyr and the function pivot_longer to convert our population data to a long format, thus making it easier to join with our measles data.\nEach column in our population dataset represents a state. To make it tidy we are going to reduce those to one column called State with the state names as the values of the column. We will then need to create a new column for population containing the current cell values. To remember that the population data is provided in 1000s of persons, we will call this new column pop1000.\npivot_longer() takes four principal arguments:\n\nthe data\ncols are the names of the columns we use to fill the new values variable (or to drop).\nthe names_to column variable we wish to create from the cols provided.\nthe values_to column variable we wish to create and fill with values associated with the cols provided.\n\n\nlibrary(tidyr)\nhist_pop_long &lt;- hist_pop %&gt;%\n  pivot_longer(ALASKA:WYOMING,\n               names_to = \"State\",\n               values_to = \"pop1000\")\n\n\nView(hist_pop_long)\n\nNow our two datasets have similar structures, a column of state names, a column of years, and a column of values. Let’s join these two datasets by the state and year columns. Note that if both sets have the same column names, you do not need to specify anything in the by argument. We use a left join here which preserves all the rows in our measles dataset and adds the matching rows from the population dataset.\n\njoined_df &lt;- yearly_count_state %&gt;% \n  left_join(hist_pop_long, by=join_by(State, Year == DATE))\n\njoined_df\n\n# A tibble: 4,055 × 4\n# Groups:   Year [96]\n    Year State         TotalCount pop1000\n   &lt;dbl&gt; &lt;chr&gt;              &lt;dbl&gt;   &lt;dbl&gt;\n 1  1906 CALIFORNIA           224    1976\n 2  1906 CONNECTICUT           23    1033\n 3  1906 FLORIDA                4     628\n 4  1906 ILLINOIS             187    5309\n 5  1906 INDIANA               20    2663\n 6  1906 KENTUCKY               2    2234\n 7  1906 MAINE                 26     729\n 8  1906 MASSACHUSETTS        282    3107\n 9  1906 MICHIGAN             320    2626\n10  1906 MISSOURI             274    3223\n# ℹ 4,045 more rows\n\n\nNow we can use our old friend mutate() to add a rate column calculated from the count and pop1000 columns.\n\nmeasles_yearly_rates &lt;-\n  joined_df %&gt;% \n  mutate(rate = TotalCount / pop1000)\n\nhead(measles_yearly_rates)\n\n# A tibble: 6 × 5\n# Groups:   Year [1]\n   Year State       TotalCount pop1000     rate\n  &lt;dbl&gt; &lt;chr&gt;            &lt;dbl&gt;   &lt;dbl&gt;    &lt;dbl&gt;\n1  1906 CALIFORNIA         224    1976 0.113   \n2  1906 CONNECTICUT         23    1033 0.0223  \n3  1906 FLORIDA              4     628 0.00637 \n4  1906 ILLINOIS           187    5309 0.0352  \n5  1906 INDIANA             20    2663 0.00751 \n6  1906 KENTUCKY             2    2234 0.000895\n\n\n\n\n\n\n\n\nCHALLENGE\n\n\n\nTry joining measles_yearly_rates to states. What variable do you need to join by?\n\n\n\n\n\n\nTip\n\n\n\n\n\n\nstates_join &lt;- measles_yearly_rates %&gt;% \nleft_join(states, by = join_by(State == name))\n\n\n\n\n\n\nNow our data is ready to be visualized!"
  },
  {
    "objectID": "01-DataWrangling.html#footnotes",
    "href": "01-DataWrangling.html#footnotes",
    "title": "Data Wrangling with R",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nhttps://www.tidyverse.org/↩︎\nread more about tidy data https://cran.r-project.org/web/packages/tidyr/vignettes/tidy-data.html↩︎\nimage from R for Data Science https://r4ds.had.co.nz/tidy-data.html#fig:tidy-structure↩︎\npopulation data retrieved from the FRED, the Federal Reserve Bank of St. Louis Economic Data, https://fred.stlouisfed.org/release/tables?rid=118&eid=259194↩︎"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site\n\n1 + 1\n\n[1] 2"
  }
]